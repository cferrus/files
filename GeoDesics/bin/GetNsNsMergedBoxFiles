#!/usr/bin/env perl

require 5;
require 'dumpvar.pl';# for pretty-printing
use strict;
use warnings;

use Getopt::Long;
use File::Copy;
use Cwd;
use POSIX qw(ceil);
use List::Util qw[min max];
use File::Basename;
# Load SpEC perl modules
use lib dirname(Cwd::abs_path(__FILE__));
use Utils;
use Machines;

# below we implement more or less a very simple parser for OptionParser's
# language:
#
# comment-or-assignment:
#   comment | assignment , comment-or-assignment
# comment:
#   #.*\n
# assignment:
#   name = value-or-comment , assignment
# name:
#   [a-zA-Z_][a-zA-Z_0-9]*
# value-or-comment:
#   value | comment
# value:
#   literal-or-nested
# literal:
#   [^();]+
# nested:
#   name(comment-or-assignment)
#
# the parser and its output will be fairly horrible since we would like to be
# able to preserve whitespace and comments when not doing any substitutions.
# This means that I cannot normalize the output but have to reproduce the
# original layout.

# re used to match parts of the language above
# whitespace and comments
my $ws = qr/(?:[[:space:]]+|(?:#[^\n]*\n))+/;
# an identifier (possibly empty)
my $id = qr/(?:[A-Za-z][A-Za-z0-9_:-]*)/;
# anything that does not have special meaning to OptionParser (possibly empty)
my $any = qr/(?:[^();#]*)/;
# floating point number
my $floatnum = qr/[+-]?(?:[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]*)?)/;

#########################################################
# Get data from old checkpoint and construct new domain
#########################################################

Utils::Die("Usage: $0 LastRunDir CheckpointDir NewInputDir") if @ARGV != 3;

my $LastRunDir    = $ARGV[0];
my $CheckpointDir = $ARGV[1];
my $NewInputDir   = $ARGV[2];
Utils::MakePathsAbsolute(\$LastRunDir,\$CheckpointDir,\$NewInputDir);
my $CurrentDir    = cwd();

# for MPI enables executables we need to use mpirun
my $MACHINE = new Machines();
my $MpiCmd = $MACHINE->GetMpiCmd(1); # run on single process

#######################################################
# Read information out of previous Run folder's files
#######################################################

my ($CpTime, $InitialDt);
my ($FinalExpansionFactor);
my (@ExtentsL, @ExtentsR, @BoundsL, @BoundsR);
my ($IDDir);
my ($SlicingCoefFormula, $DtSlicingCoefFormula, $ShiftCoefFormula,
    $DtShiftCoefFormula, $TimeRolloffFormula, $DtTimeRolloffFormula);
my ($DomainSymmetry);
my ($TdampTrans, $TdampExpansion, $TdampRotation);
my @Variables = (
  "$CheckpointDir/Cp-TimeStepperPI.dat" => [
    "assign(Time)" => \$CpTime,
    "assign(NextDt)" => \$InitialDt,
  ],
  "$CheckpointDir/Cp-FuncExpansionFactor.txt" => [
    "assign(a)" => \$FinalExpansionFactor,
  ],
  "$CheckpointDir/Cp-TdampTrans.txt" => [
    "assign(Timescale),tag()" => \$TdampTrans,
  ],
  "$CheckpointDir/Cp-TdampExpansion.txt" => [
    "assign(Timescale),tag()" => \$TdampExpansion,
  ],
  "$CheckpointDir/Cp-TdampQuatRotMatrix.txt" => [
    "assign(Timescale),tag()" => \$TdampRotation,
  ],
  "$LastRunDir/HyDomain.input" => [
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalL)),assign(x-Axis),tag(),assign(Extents)" => \$ExtentsL[0],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalL)),assign(y-Axis),tag(),assign(Extents)" => \$ExtentsL[1],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalL)),assign(z-Axis),tag(),assign(Extents)" => \$ExtentsL[2],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalR)),assign(x-Axis),tag(),assign(Extents)" => \$ExtentsR[0],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalR)),assign(y-Axis),tag(),assign(Extents)" => \$ExtentsR[1],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalR)),assign(z-Axis),tag(),assign(Extents)" => \$ExtentsR[2],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalL)),assign(x-Axis),tag(),assign(Bounds)" => \$BoundsL[0],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalL)),assign(y-Axis),tag(),assign(Bounds)" => \$BoundsL[1],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalL)),assign(z-Axis),tag(),assign(Bounds)" => \$BoundsL[2],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalR)),assign(x-Axis),tag(),assign(Bounds)" => \$BoundsR[0],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalR)),assign(y-Axis),tag(),assign(Bounds)" => \$BoundsR[1],
    "assign(SubdomainStructure),tag(PerimBlocks(assign(BaseName)=IntervalR)),assign(z-Axis),tag(),assign(Bounds)" => \$BoundsR[2],
  ],
  "$LastRunDir/HyInitialData.input" => [
    "assign(DataBoxItems),tag(Domain),assign(Items),tag(ReadTensorsFromDisk.*),assign(Dir)"=> \$IDDir,
  ],
  "$LastRunDir/Evolution.input" => [
    "assign(OdeIntegrator),tag(AdaptiveDense),assign(OdeStepper),tag(.*),
     assign(ExplicitRhsAlgorithm),tag(MultiDomainHydro),
     assign(ExplicitRhsAlgorithmFiniteDifference),tag(GhostZone),
     assign(DomainSymmetry)" => \$DomainSymmetry,
  ],
  "$LastRunDir/GaugeItems.input" => [
    "assign(DataBoxItems),tag(Subdomain),assign(Items),
     tag(AddDampedHarmonicGaugeItems),assign(SlicingCoef)" => 
     \$SlicingCoefFormula,
    "assign(DataBoxItems),tag(Subdomain),assign(Items),
     tag(AddDampedHarmonicGaugeItems),assign(DtSlicingCoef)" => 
     \$DtSlicingCoefFormula,
    "assign(DataBoxItems),tag(Subdomain),assign(Items),
     tag(AddDampedHarmonicGaugeItems),assign(ShiftCoef)" => 
     \$ShiftCoefFormula,
    "assign(DataBoxItems),tag(Subdomain),assign(Items),
     tag(AddDampedHarmonicGaugeItems),assign(DtShiftCoef)" => 
     \$DtShiftCoefFormula,
    "assign(DataBoxItems),tag(Subdomain),assign(Items),
     tag(AddDampedHarmonicGaugeItems),assign(TimeRolloff)" => 
     \$TimeRolloffFormula,
    "assign(DataBoxItems),tag(Subdomain),assign(Items),
     tag(AddDampedHarmonicGaugeItems),assign(DtTimeRolloff)" => 
     \$DtTimeRolloffFormula,
  ],
);

while (my ($filename, $vars) = splice(@Variables,0,2)) {
  my $text = Utils::ReadFile("$filename");
  while (my ($paths, $var) = splice(@$vars,0,2)) {
    if (ref $paths) { # list of possible paths, try them each in order
      foreach my $path (@$paths) {
        $$var = GetElementValue($text, $paths, undef);
        last if defined $$var;
      }
      Utils::Die("Could not extract any of (".
                 join(",",map {"'".$_."'"} @$paths).") from '$text'")
                 if not defined($$var);
    } else { # single path, use it
      $$var = GetElementValue($text, $paths, undef);
      Utils::Die("Could not extract '$paths' from '$text'") if not defined($$var);
    }
  }
}

#my %RegridderMapL = GetRegridderMap("$CheckpointDir/$LeftCpFile", $CpTime, 1e-10);
#my %RegridderMapR = GetRegridderMap("$CheckpointDir/$RightCpFile", $CpTime, 1e-10);
# the checkpoint files contain incorrect data (sigh) when we terminate due to
# already overlapping grids. The history files on the other hand contain the correct information
# we need to support both files using the unsplit regridder where we read map
# parameters from history files and the split regridder where the map
# parameters are stored as FvT objects

# the new domain covers the mapped region of the two old boxes
my @MappedLowerL;
my @MappedUpperL;
my @MappedLowerR;
my @MappedUpperR;
my $FinalMapString;
my @SymmetricInDirection;

if ($DomainSymmetry eq "None") {
  @SymmetricInDirection = (0,0,0);
} elsif ($DomainSymmetry eq "ReflectZ") {
  @SymmetricInDirection = (0,0,1);
} elsif ($DomainSymmetry eq "ReflectXYZ") {
  @SymmetricInDirection = (1,1,1);
} else {
  Utils::Die("Only coded symmetries in are None, ReflectXYZ and ReflectZ, ".
             "you specified $DomainSymmetry");
} 

if (-e "$LastRunDir/HydroMapHistory.dat") {
  my @mapparams = GetRegridderMapsFromHistoryFile("$LastRunDir/HydroMapHistory.dat", $CpTime, 1e-10);
  my %RegridderMapL = splice @mapparams,0,scalar(@mapparams)/2;
  my %RegridderMapR = @mapparams;
  my (@BoundsLLower,@BoundsLUpper,@BoundsRLower,@BoundsRUpper);

  for (my $d = 0 ; $d < 3 ; $d++) {
    my @lowhighL = split(",", $BoundsL[$d]);
    my @lowhighR = split(",", $BoundsR[$d]);

    $BoundsLLower[$d] = eval($lowhighL[0]);
    $BoundsLUpper[$d] = eval($lowhighL[1]);

    $BoundsRLower[$d] = eval($lowhighR[0]);
    $BoundsRUpper[$d] = eval($lowhighR[1]);
  }

  # re-constructed map between domains at checkpoint time
  my @Offset1L = @{$RegridderMapL{'Offset1'}};
  my @ScaleVecL = @{$RegridderMapL{'ScaleVec'}};
  my @Offset2L = @{$RegridderMapL{'Offset2'}};
  my @Offset1R = @{$RegridderMapR{'Offset1'}};
  my @ScaleVecR = @{$RegridderMapR{'ScaleVec'}};
  my @Offset2R = @{$RegridderMapR{'Offset2'}};

   @MappedLowerL = MapPoint(\%RegridderMapL, \@BoundsLLower);
   @MappedUpperL = MapPoint(\%RegridderMapL, \@BoundsLUpper);
   @MappedLowerR = MapPoint(\%RegridderMapR, \@BoundsRLower);
   @MappedUpperR = MapPoint(\%RegridderMapR, \@BoundsRUpper);

   $FinalMapString = "NsNsSeparatedMaps(
   SeparatrixCoord=0.;
   SeparatrixAxis=0;
   LeftMap=Offset(Offset=$Offset1L[0],$Offset1L[1],$Offset1L[2];)>>
           RescaleAxes(scaleVec=$ScaleVecL[0],$ScaleVecL[1],$ScaleVecL[2];)>>
           Offset(Offset=$Offset2L[0],$Offset2L[1],$Offset2L[2];);
   RightMap=Offset(Offset=$Offset1R[0],$Offset1R[1],$Offset1R[2];)>>
           RescaleAxes(scaleVec=$ScaleVecR[0],$ScaleVecR[1],$ScaleVecR[2];)>>
           Offset(Offset=$Offset2R[0],$Offset2R[1],$Offset2R[2];);
   )";
} elsif (-e "$CheckpointDir/FinalLayout.txt") {
  my @vars = (
    "assign(LowerBoundLeft)" => \@MappedLowerL,
    "assign(UpperBoundLeft)" => \@MappedUpperL,
    "assign(LowerBoundRight)" => \@MappedLowerR,
    "assign(UpperBoundRight)" => \@MappedUpperR,
  );
  my $text = Utils::ReadFile("$CheckpointDir/FinalLayout.txt");
  while (my ($path, $var) = splice(@vars,0,2)) {
    my $vartext = GetElementValue($text, $path, undef);
    @$var = split ",", $vartext;
  }
  $FinalMapString = GetElementValue($text, "assign(FinalMap)", undef);
  if (not defined $FinalMapString) {
    Utils::Die("Could not read 'FinalMap' out of '$CheckpointDir/FinalLayout.txt' file");
  }
} else {
    Utils::Die("Do not know how to obtain map at end of run. Tried 'HydroMapHistory.dat' and 'FinalLayout.txt'");
}
  

for (my $d = 0 ; $d < 3 ; $d++) {
  $ExtentsL[$d] = eval($ExtentsL[$d]);
  $ExtentsR[$d] = eval($ExtentsR[$d]);
}

# this runs ApplyObservers to get the Gauge parameters that were active at the
# time of checkpoint
# NOTE: this assumes that $PATH is set up properly to contain the Run's bin
# folder
my (%GaugeParams);
my $GaugeParamApplyObserversCall = <<EOF;
$MpiCmd ApplyObservers -domaininput "GrDomain.input" \\
               -PhysicalTimeStart $CpTime \\
               -PhysicalTimeEnd $CpTime -Steps 1 \\
-c "
  Domain(Items=
  EvaluateDoubleFormula(Output=SlicingCoef;
                        AddTime=true;
                        Formula=$SlicingCoefFormula;),
  EvaluateDoubleFormula(Output=DtSlicingCoef;
                        AddTime=true;
                        Formula=$DtSlicingCoefFormula;),
  EvaluateDoubleFormula(Output=ShiftCoef;
                        AddTime=true;
                        Formula=$ShiftCoefFormula;),
  EvaluateDoubleFormula(Output=DtShiftCoef;
                        AddTime=true;
                        Formula=$DtShiftCoefFormula;),
  EvaluateDoubleFormula(Output=TimeRolloff;
                        AddTime=true;
                        Formula=$TimeRolloffFormula;),
  EvaluateDoubleFormula(Output=DtTimeRolloff;
                        AddTime=true;
                        Formula=$DtTimeRolloffFormula;),
  )" \\
-o "
  ObserveDoubles(Input=SlicingCoef,DtSlicingCoef, ShiftCoef,DtShiftCoef,
                       TimeRolloff,DtTimeRolloff;
                 Filename=$NewInputDir/GaugeParamsAtCheckpointTime.output;)"
EOF
chdir $LastRunDir;
Utils::SystemOutput($GaugeParamApplyObserversCall);
chdir $CurrentDir;
%GaugeParams =
  ReadLastLineOfDatFile("$NewInputDir/GaugeParamsAtCheckpointTime.output");

# keep only the first element of the list that was read out of the checkpoints
$TdampTrans =~ s/,.*$//;
$TdampExpansion =~ s/,.*$//;
$TdampRotation =~ s/,.*$//;

########################################################################
# Compute new domain etc. based on infortmation retrieved from old files
########################################################################

# merge the left and right box and compute their bounds in the old mapped coords
# these coordinates will be the new grid coordinates since the regridders
# assume (with default parameters) that the initial map between hydro and
# spectral grid is the identity map
my (@MappedLower, @MappedUpper);
for(my $d = 0 ; $d <= $#MappedLowerL ; $d++) {
  $MappedLower[$d] = min($MappedLowerL[$d], $MappedLowerR[$d]);
  $MappedUpper[$d] = max($MappedUpperL[$d], $MappedUpperR[$d]);
  if($MappedLower[$d] * $MappedUpper[$d] > 0) {
    Utils::Die("Mapped domain does not straddle origin in $d direction: (${MappedLower[$d]},${MappedUpper[$d]}). I am not sure if I can handle this");
  }
}

# compute directions with highest mapped resolution
my (@delta, @mindelta);
for(my $d = 0 ; $d <= $#MappedLower ; $d++) {
  $delta[$d] = min(($MappedUpperL[$d]-$MappedLowerL[$d]) / ($ExtentsL[$d] - 1),
                   ($MappedUpperR[$d]-$MappedLowerR[$d]) / ($ExtentsR[$d] - 1));
}
Utils::Die("I currently assume 3d data") if scalar @MappedLower != 3;
$mindelta[0] = min($delta[0], $delta[1], $delta[2]) / 1.5;
$mindelta[1] = $mindelta[0];
$mindelta[2] = $mindelta[0];

# make symmetric around the origin in x,y,z
# make bounds multiple of of step size
# having an odd number of grid points is useful for FMR
# we currenlyt have a bug in IntegrationWeightMask that produces wrong weights
# unless grids align
my @Extents;
for(my $d = 0 ; $d <= $#MappedLower ; $d++) {
  my $maxbound = max(abs($MappedLower[$d]), abs($MappedUpper[$d]));
  my $granularity = 2;
  my $ncells = ceil($maxbound / $mindelta[$d]);
  my $npoints;
  $ncells = ceil($ncells / $granularity) * $granularity;
  $maxbound = $ncells * $mindelta[$d];
  $MappedUpper[$d] = $maxbound;
  $npoints = $ncells+1;
  if(not $SymmetricInDirection[$d]) {
    $MappedLower[$d] = -$maxbound;
    $npoints += $ncells;
  } else {
    $MappedLower[$d] = 0.;
  }

  $Extents[$d] = $npoints;
}

my @Bounds = map {($MappedLower[$_],$MappedUpper[$_])} (0..$#MappedUpper);

my $EvolutionParamsFile = "$IDDir/EvolutionParameters.perl";

###################################
# Start modifying/generating files 
###################################

# TODO: extract state changers from old input files
my @Changes = ();
my @Insertions = ();

# modify files (first all subsitutions, then all insertions)
while (my ($filename, $changes) = splice(@Changes,0,2)) {
  #print STDERR "Changing $filename\n";
  my $text = Utils::ReadFile("$NewInputDir/$filename");
  while (my ($path, $change) = splice(@$changes,0,2)) {
    $text = SubstituteElement($text, $path, $change);
  }
  Utils::OverwriteFile("$NewInputDir/$filename", $text);
  #print STDERR "Done changing $filename\n";
}
while (my ($filename, $changes) = splice(@Insertions,0,2)) {
  #print STDERR "Adding to $filename\n";
  my $text = Utils::ReadFile("$NewInputDir/$filename");
  while (my ($path, $change) = splice(@$changes,0,2)) {
    $text = InsertElement($text, $path, $change);
  }
  Utils::OverwriteFile("$NewInputDir/$filename", $text);
  #print STDERR "Done adding to $filename\n";
}

my $eol = "\n";
Utils::OverwriteFile("$NewInputDir/MergedBoxesParameters.perl",
'@Extents = (' . join(",",@Extents) . ');' . $eol . 
'@Bounds = (' . join(",",@Bounds) . ');' . $eol . 
'$FinalMapString = "' . $FinalMapString . '";' . $eol .
'$OldRunDir = "' . $LastRunDir . '";' . $eol .
'$CpDir = "' . $CheckpointDir . '";' . $eol .
'$CpTime = ' . $CpTime . ';' . $eol .
'$InitialDt = ' . $InitialDt . ';' . $eol .
'$EvolutionParamsFile = "' . $EvolutionParamsFile . '";' . $eol .
'$InitialExpansionFactor = ' . $FinalExpansionFactor . ';' . $eol .
'$SlicingCoefAtCheckpointTime = ' . $GaugeParams{"SlicingCoef"} . ';' . $eol .
'$DtSlicingCoefAtCheckpointTime = ' . $GaugeParams{"DtSlicingCoef"} . ';' . $eol .
'$ShiftCoefAtCheckpointTime = ' . $GaugeParams{"ShiftCoef"} . ';' . $eol .
'$DtShiftCoefAtCheckpointTime = ' . $GaugeParams{"DtShiftCoef"} . ';' . $eol .
'$TimeRolloffAtCheckpointTime = ' . $GaugeParams{"TimeRolloff"} . ';' . $eol .
'$DtTimeRolloffAtCheckpointTime = ' . $GaugeParams{"DtTimeRolloff"} . ';' . $eol .
'$TdampTrans = ' . $TdampTrans . ';' . $eol .
'$TdampExpansion = ' . $TdampExpansion . ';' . $eol .
'$TdampRotation = ' . $TdampRotation . ';' . $eol .
'1; # terminate file' . $eol
);

exit;

# read dat file and do some rudimentary header parsing
sub ReadLastLineOfDatFile {
  my ($fn) = @_;
  my ($text, %fields);

  open(FILE, $fn) or Utils::Die("Cannot open '$fn'");
  my $in_header = 1;
  while(<FILE>) {
    s/\s*$//;
    s/^\s*//;
    if(/^ *#/) {
      if($in_header) {
        m/^# \[([1-9][0-9]*)\] = (.*)$/ or Utils::Die("Could not parse header line '$_' of file '$fn'");
        my ($fieldnum,$fieldname) = ($1,$2);
        $fields{$fieldname} = $fieldnum-1;
      }
      # ignore comments outside of header
    } else {
      $in_header = 0; # first non-comment line ends header
      $text = $_;
    }
  }
  close(FILE) or Utils::Die("Cannot close '$fn'");
  my @data = split /\s+/,$text;
  if(scalar @data != scalar (keys %fields)) {
    Utils::Die("Data in last line of file '$fn', number of fields (" . 
        scalar @data .") does not match header");
  }
  foreach my $key (keys %fields) {
    $fields{$key} = $data[$fields{$key}];
  }
  return %fields;
}

# primitive tokenizer of string
sub tokenize {
  my ($opts) = @_;

  # I remove empty strings since these are only created when two
  # separators abut
  return grep {$_ ne ""} split(/($ws|[(),;=])/, $opts);
}

# split off a single assignment of the form a(...)?=b(...)?;
sub SplitAssignment {
  my ($opts) = @_;
  my (@tokens) = tokenize($opts);
  my ($head, $lhs, $middle, $rhs, $tail) = ("")x5;
  my $token;
  my $nesting_level = 0;

  $head .= shift @tokens if (scalar @tokens and $tokens[0] =~ m/^$ws$/s);
  Utils::Die("Assignments cannot be empty at $opts stopped at") if not scalar @tokens;
  
  while (scalar @tokens and ($tokens[0] ne "=" and 
                             not ($tokens[0] =~ m/^$ws$/s and
                                  scalar @tokens >= 2 and 
                                  $tokens[1] eq "=") or
                             $nesting_level > 0)) {
    $token = shift @tokens;
    $lhs .= $token;
    $nesting_level++ if($token eq "(");
    $nesting_level-- if($token eq ")");
  }
  Utils::Die("Improperly nested parens in $opts stopped at") if $nesting_level > 0;
  
  $middle .= shift @tokens while (scalar @tokens and $tokens[0] =~ m/^$ws$/s);
  if(scalar @tokens and $tokens[0] eq "=") {
    $middle .= shift @tokens;
  } else {
    Utils::Die("Assignment missing '=': $opts stopped at");
  } 
  $middle .= shift @tokens while (scalar @tokens and $tokens[0] =~ m/^$ws$/s);

  while (scalar @tokens and (($tokens[0] ne ";" 
                              and not ($tokens[0] =~ m/^$ws$/ and scalar @tokens == 1))
                             or $nesting_level > 0)) {
    $token = shift @tokens;
    $rhs .= $token;
    $nesting_level++ if($token eq "(");
    $nesting_level-- if($token eq ")");
  }  
  Utils::Die("Improperly nested parens in $opts stopped at") if $nesting_level > 0;

  $tail .= shift @tokens if (scalar @tokens and $tokens[0] eq ";");
  $tail .= shift @tokens if (scalar @tokens and $tokens[0] =~ m/^$ws$/s);

  return ($head,$lhs,$middle,$rhs,$tail,join("",@tokens));
}

# Split set of assignments A = B,C; D = E; ...
sub SplitAssignments {
  my($opts) = @_;
  my $orig_opts = $opts;
  my @retval;
  
  while($opts and my ($head,$lhs,$middle,$rhs,$tail,$leftover) = SplitAssignment($opts)) {
    push @retval, {"head" => $head, "lhs" => $lhs, "middle" => $middle, "rhs" => $rhs, "tail" => $tail};
    $opts = $leftover;
  }

  Utils::Die("Could not fully split assignments '$orig_opts'. Unparsable part: '$opts'") if defined($opts) and length($opts);

  return @retval;
}

# split off the first element in a comma separated list
sub LowLevelListHead {
  my ($opts) = @_;
  my (@tokens) = tokenize($opts);
  my ($head);
  my $token;
  my $nesting_level = 0;

  while (scalar @tokens and ($tokens[0] ne "," or $nesting_level > 0)) {
    $token = shift @tokens;
    $head .= $token;
    $nesting_level++ if($token eq "(");
    $nesting_level-- if($token eq ")");
  }
  Utils::Die("Improperly nested options $opts stopped at") if $nesting_level > 0;
  
  $head .= shift @tokens if(scalar @tokens and $tokens[0] eq ",");
  $head .= shift @tokens if(scalar @tokens == 1 and $tokens[0] =~ m/^$ws$/); 
  
  return ($head,join("",@tokens));
}

# Split a comma separated list A, B, C ...
# this keeps ws and other junk with the elements
sub LowLevelSplitList {
  my($opts) = @_;
  my $orig_opts = $opts;
  my @retval;

  while($opts and my ($head, $leftover) = LowLevelListHead($opts)) {
    my $elem = $head;
    $opts = $leftover;
    push @retval, $elem;
  }
  #print "Split '$orig_opts' into ",join(":",@retval),":\n";

  Utils::Die("Could not fully split list '$orig_opts', unparsed part '$opts' stopped at") if $opts;

  return @retval;
}

# Split a tag-value pair tag(value)
sub SplitTag {
  my($opts) = @_;
  my (@tokens) = tokenize($opts);
  my ($head, $tag, $middle, $value, $tail, $tailhead, $tailtail) = ("")x7;
  my ($token, %retval);
  my $nesting_level = 0;

  Utils::Die("Improperly balanced parens in $opts stopped at") if scalar grep('[(]',$opts) != scalar grep('[(]',$opts);

  $head .= shift @tokens if (scalar @tokens and $tokens[0] =~ m/^$ws$/s);
  Utils::Die("Tags cannot contain only whitespace: $opts stopped at") if not scalar @tokens;
  
  while (scalar @tokens and ($tokens[0] ne "(" and $tokens[0] !~ m/^$ws$/)) {
    $token = shift @tokens;
    $tag .= $token;
  }
  
  $middle .= shift @tokens if (scalar @tokens and $tokens[0] =~ m/^$ws$/s);
  if(scalar @tokens and $tokens[0] eq "(") {
    $middle .= shift @tokens;
    $middle .= shift @tokens if (scalar @tokens and $tokens[0] =~ m/^$ws$/s);

    while (scalar @tokens and (($tokens[0] ne ")" 
                                and not ($tokens[0] =~ m/^$ws$/ and scalar @tokens == 1))
                               or $nesting_level > 0)) {
      $token = shift @tokens;
      $value .= $token;
      $nesting_level++ if($token eq "(");
      $nesting_level-- if($token eq ")");
    }
    Utils::Die("Improperly nested parens in $opts stopped at") if $nesting_level > 0;
    
    $tail .= shift @tokens if (scalar @tokens and $tokens[0] =~ m/^$ws$/s);
    if(scalar @tokens and $tokens[0] eq ")") {
      $tail .= shift @tokens;
    } else {
      Utils::Die("Improperly nested parens in $opts stopped at");
    }
    $tail .= shift @tokens if (scalar @tokens and $tokens[0] =~ m/^$ws$/s);
    $tail .= shift @tokens if (scalar @tokens and $tokens[0] eq ",");
    $tail .= shift @tokens if (scalar @tokens and $tokens[0] =~ m/^$ws$/s);
  } else {
    $tail = $middle;
    $middle = "";
  }

  Utils::Die("Could not split tag $opts. Found:".
      join(",",($head, $tag, $middle, $value, $tail))." left: ".
      join(":",@tokens).".") if scalar @tokens;

  $tail =~ m/($ws?\))(.*)/;
  $tailhead = defined($1) ? $1 : "";
  $tailtail = defined($2) ? $2 : "";

  $retval{"head"} = $head;
  $retval{"tag"} = $tag;
  $retval{"middle"} = $middle;
  $retval{"value"} = $value;
  $retval{"tail"} = $tail;
  $retval{"tailhead"} = $tailhead;
  $retval{"tailtail"} = $tailtail;

  return %retval;
}

# TODO: beautify path syntax. The following postfix notation should also be
# usable:
# A=B=C(D(E=F()))
# it does away with the list which can only ever contain tags anyway.
# the closing parens are probably going to be ignored, they are unneccesary
# anyway

# add a mew element in an options string to an existing option
# call syntax:
#   $text     - the full option string
#   $element  - path to match the element of form: 
#               assign(lhsName),tag(tagName) 
#               for '=' and lists of tagged strings
#   $value    - replacement value, incl. ';,()\n' tagName etc
#   $optional - if true, do not complain if element is not found
# returns $text after insertion
sub InsertElement {
  my($text, $element, $value, $optional) = @_;
  my $did_add = 0;
  
  my $retval = InternalInsertElement($text, $element, $value, \$did_add);

  Utils::Die("Did not find '$element': $text stopped at") if not $did_add and not $optional;

  return $retval;
}
        
sub InternalInsertElement {
  my($text, $element, $value, $did_add) = @_;
  my @elements = LowLevelSplitList($element);
  my $pattern = shift @elements;
  my %head = SplitTag($pattern);
  my $type = $head{"tag"};
  my $tag = $head{"value"};
  my $newtext;

  my $extraconds = "";
  if($tag =~ m/\(/) {
    my %condtag = SplitTag($tag);
    $tag = $condtag{"tag"};
    $extraconds = $condtag{"value"};
  }

  #print STDERR "Looking for $pattern in $text\n";
  if($type eq "assign") {
    my @assignments = SplitAssignments($text);
    Utils::Die("Could not split '$text' stopped at") unless @assignments;
    foreach my $assignment (@assignments) {
      if($assignment->{"lhs"} =~ m/^$tag$/s and MatchConditions($assignment->{"rhs"}, $extraconds)) {
        if(scalar @elements == 0) {
          $newtext .= $assignment->{"head"}.$assignment->{"lhs"}.$assignment->{"middle"}.$value.$assignment->{"rhs"}.$assignment->{"tail"};
	  $$did_add++;
        } else {
          $newtext .= $assignment->{"head"}.$assignment->{"lhs"}.$assignment->{"middle"}.InternalInsertElement($assignment->{"rhs"}, join("",@elements), $value, $did_add).$assignment->{"tail"};
        }
      } else {
        $newtext .= $assignment->{"head"}.$assignment->{"lhs"}.$assignment->{"middle"}.$assignment->{"rhs"}.$assignment->{"tail"};
      }
    }
  } elsif($type eq "tag") {
    foreach my $i (LowLevelSplitList($text)) {
      my %tagval = SplitTag($i);
      Utils::Die("Could not split tag '$i' stopped at") unless %tagval;
      if($tagval{"tag"} =~ m/^$tag$/s and MatchConditions($tagval{"value"}, $extraconds)) { 
        if(scalar @elements == 0) {
          $newtext .= $tagval{"head"} . $tagval{"tag"} . $tagval{"middle"} . $value . $tagval{"value"} . $tagval{"tail"};
	  $$did_add++;
        } else {
          $newtext .= $tagval{"head"} . $tagval{"tag"} . $tagval{"middle"} . InternalInsertElement($tagval{"value"}, join("",@elements), $value, $did_add) . $tagval{"tail"};
        }
      } else {
        $newtext .= $i;
      }
    }
  } elsif($type eq "beginning") {
    $newtext = $value . $text;
    $$did_add++;
  } else {
    Utils::Die("Unknown type '$type' from '$pattern' stopped at");
  }

  return $newtext;
}

# replace an element in an options string
# call syntax:
#   $text     - the full option string
#   $element  - path to match the element of form: 
#               assign(lhsName),tag(tagName) 
#               for '=' and lists of tagged strings
#   $value    - replacement value, incl. ';,()\n' tagName etc
#   $optional - if true, do not complain if element is not found
# returns $text after substitution
sub SubstituteElement {
  my($text, $element, $value, $optional) = @_;
  my $did_substitute = 0;

  my $retval = InternalSubstituteElement($text, $element, $value, \$did_substitute);
  Utils::Die("Did not find '$element': $text stopped at") if not $did_substitute and not $optional;

  return $retval;
}
sub InternalSubstituteElement {
  my($text, $element, $value, $did_substitute) = @_;
  my @elements = LowLevelSplitList($element);
  my $pattern = shift @elements;
  my %head = SplitTag($pattern);
  my $type = $head{"tag"};
  my $tag = $head{"value"};
  my $newtext;

  my $extraconds;
  if($tag =~ m/\(/) {
    my %condtag = SplitTag($tag);
    $tag = $condtag{"tag"};
    $extraconds = $condtag{"value"};
  }

  if($type eq "assign") {
    my @assignments = SplitAssignments($text);
    Utils::Die("Could not split '$text' stopped at") unless @assignments;
    foreach my $assignment (@assignments) {
      if(($assignment->{"lhs"} =~ m/^$tag$/s) and MatchConditions($assignment->{"rhs"}, $extraconds)) {
        if(scalar @elements == 0) {
          # FIXME: introduce a proper RemoveValue function rather than this fudge
          if($value ne "") {
            $newtext .= $assignment->{"head"}.$value.$assignment->{"tail"};
          }
	  $$did_substitute++;
        } else {
          $newtext .= $assignment->{"head"}.$assignment->{"lhs"}.$assignment->{"middle"}.InternalSubstituteElement($assignment->{"rhs"}, join("",@elements), $value, $did_substitute).$assignment->{"tail"};
        }
      } else {
        $newtext .= $assignment->{"head"}.$assignment->{"lhs"}.$assignment->{"middle"}.$assignment->{"rhs"}.$assignment->{"tail"};
      }
    }
  } elsif($type eq "tag") {
    foreach my $i (LowLevelSplitList($text)) {
      my %tagval = SplitTag($i);
      Utils::Die("Could not split tag '$i' stopped at") unless %tagval;
      if(($tagval{"tag"} =~ m/^$tag$/s) and MatchConditions($tagval{"value"}, $extraconds)) { 
        if(scalar @elements == 0) {
          # FIXME: introduce a proper RemoveValue function rather than this fudge
          if($value ne "") {
            $newtext .= $tagval{"head"} . $value . $tagval{"tailtail"}; # not tail since tail contains the ")," part
          }
	  $$did_substitute++;
        } else {
          $newtext .= $tagval{"head"} . $tagval{"tag"} . $tagval{"middle"} . InternalSubstituteElement($tagval{"value"}, join("",@elements), $value, $did_substitute) . $tagval{"tail"};
        }
      } else {
        $newtext .= $i;
      }
    }
  } else {
    Utils::Die("Unknown type '$type' from '$pattern' stopped at");
  }

  return $newtext;
}

# return an element in an options string
# call syntax:
#   $text    - the full option string
#   $element - path to match the element of form: 
#              assign(lhsName),tag(tagName)
#              for '=', lists of tagged strings
#   $default - what to return if the option does not exist
# returns $value of option
# TODO: in list context, return all matching values
sub GetElementValue {
  my($text, $element, $defval) = @_;
  my @elements = LowLevelSplitList($element);
  my $pattern = shift @elements;
  my %head = SplitTag($pattern);
  my $type = $head{"tag"};
  my $tag = $head{"value"};
  my $retval = $defval;

  my $extraconds;
  if($tag =~ m/\(/) {
    my %condtag = SplitTag($tag);
    $tag = $condtag{"tag"};
    $extraconds = $condtag{"value"};
  }

  #print "t '$type'\n";
  #print "v '$tag'\n";

  if($type eq "assign") {
    my @assignments = SplitAssignments($text);
    Utils::Die("Could not split '$text' stopped at") unless @assignments;
    foreach my $assignment (@assignments) {
      #print "'$assignment->{'lhs'}' eq '$assignment->{'rhs'}'\n";
      if($assignment->{"lhs"} =~ m/^$tag$/s and MatchConditions($assignment->{"rhs"}, $extraconds)) {
        if(scalar @elements == 0) {
          $retval = $assignment->{"rhs"};
          $retval =~ s/^$ws//;
          $retval =~ s/$ws(?:;$ws)*$//;
        } else {
          $retval = GetElementValue($assignment->{"rhs"}, join("",@elements), $defval);
        }
        last;
      }
    }
  } elsif($type eq "tag") {
    foreach my $i (LowLevelSplitList($text)) {
      my %tagval = SplitTag($i);
      #print "'$tagval{'tag'}' => '$tagval{'value'}'\n";
      Utils::Die("Could not split tag '$i' stopped at") unless %tagval;
      if($tagval{"tag"} =~ m/^$tag$/s and MatchConditions($tagval{"value"}, $extraconds)) { 
        if(scalar @elements == 0) {
          $retval = $tagval{"value"};
        } else {
          $retval = GetElementValue($tagval{"value"}, join("",@elements), $defval);
        }
        last;
      }
    }
  } else {
    Utils::Die("Unknown type '$type' from '$pattern' stopped at");
  }

  # instead of dieing we return undef if the path is not found

  return $retval;
}

# matches a list of path=pattern values against a text string of options
sub MatchConditions {
  my ($text, $condstring) = @_;
  my @conditions = SplitAssignments($condstring);
  my $retval = 1;

  foreach my $cond (@conditions) {
    my $path = $cond->{"lhs"};
    my $match = $cond->{"rhs"};
    #print STDERR "matching '$path' to '$match' in '$text'\n";
    my $value = GetElementValue($text, $path, undef);
    if(not defined($value) or $value !~ m/$match/) {
      $retval = 0;
      last;
    }
  }
  #print STDERR "done: $retval\n" if $condstring;

  return $retval;
}

# gets the parameters controlling the coordmap created by the outflow
# regridders out of its checkpoint file at time == $Time
sub GetRegridderMap {
  my ($filename, $Time, $Eps) = @_;
  my %mapparams;

  open(FILE,"<$filename") or Utils::Die("Cannot open $filename");
  while(my $line = <FILE>) {
    Utils::Die("Could not parse $filename line $line stopped at") unless $line =~ m/^[[:space:]]*(?:${floatnum}[[:space:]]+){14}/;
    $line =~ s/^[[:space:]]*//;
    my @elems = split /[[:space:]]+/,$line;
    my $time = $elems[0];
    my @Offset1 = (-$elems[1],-$elems[2],-$elems[3]); # map is constructed with -CenterComov
    my @ScaleVec = ($elems[4],$elems[5],$elems[6]);
    my @Offset2 = ($elems[7],$elems[8],$elems[9]);
    if (abs($Time-$time) <= $Eps) {
      $mapparams{"time"} = $time;
      $mapparams{"Offset1"} = \@Offset1;
      $mapparams{"ScaleVec"} = \@ScaleVec;
      $mapparams{"Offset2"} = \@Offset2;
      last;
    }
  }
  close(FILE) or Utils::Die("Cannot close $filename");

  Utils::Die("Could not parse $filename stopped at") unless %mapparams;
  
  return %mapparams;
}

# gets the parameters controlling the coordmap created by the outflow
# regridders out of a history file at time == $Time
sub GetRegridderMapsFromHistoryFile {
  my ($filename, $Time, $Eps) = @_;
  my (%mapparamsLeft, %mapparamsRight);

  open(FILE,"<$filename") or Utils::Die("Cannot open $filename");
  while(my $line = <FILE>) {
    my $reInner = qr/Offset\(Offset=\s*(${floatnum}),\s*(${floatnum}),\s*(${floatnum});\)>>/ . 
                  qr/RescaleAxes\(scaleVec=\s*(${floatnum}),\s*(${floatnum}),\s*(${floatnum});\)>>/ .
                  qr/Offset\(Offset=\s*(${floatnum}),\s*(${floatnum}),\s*(${floatnum});\)/;
    my $re = qr/\s*(${floatnum})\s*,\s*CoordToSpatialCoordMap\(CoordMap=/ .
             qr/NsNsSeparatedMaps\(SeparatrixCoord\s*=\s*${floatnum};\s*SeparatrixAxis\s*=\s*0;\s*LeftMap\s*=\s*/ .
             $reInner . qr/;\s*RightMap\s*=\s*/ . $reInner . qr/;\)\)/;
    Utils::Die("Could not parse $filename line $line stopped at") unless $line =~ m/$re/;
    my $time = $1;
    my @OffsetLeft1 = ($2,$3,$4);
    my @ScaleVecLeft = ($5,$6,$7);
    my @OffsetLeft2 = ($8,$9,$10);
    my @OffsetRight1 = ($11,$12,$13);
    my @ScaleVecRight = ($14,$15,$16);
    my @OffsetRight2 = ($17,$18,$19);
    if (abs($Time-$time) <= $Eps) {
      $mapparamsLeft{"time"} = $time;
      $mapparamsLeft{"Offset1"} = \@OffsetLeft1;
      $mapparamsLeft{"ScaleVec"} = \@ScaleVecLeft;
      $mapparamsLeft{"Offset2"} = \@OffsetLeft2;
      $mapparamsRight{"time"} = $time;
      $mapparamsRight{"Offset1"} = \@OffsetRight1;
      $mapparamsRight{"ScaleVec"} = \@ScaleVecRight;
      $mapparamsRight{"Offset2"} = \@OffsetRight2;
      last;
    }
  }
  close(FILE) or Utils::Die("Cannot close $filename");

  Utils::Die("Could not parse $filename stopped at") unless (%mapparamsLeft and %mapparamsRight);
  
  return (%mapparamsLeft, %mapparamsRight);
}

sub MapPoint {
  my ($mapparamsref, $pointref) = @_;
  my @point = @{$pointref};
  my %mapparams = %{$mapparamsref};
  my @retval = @point;

  my @Offset1 = @{$mapparams{"Offset1"}};
  my @ScaleVec = @{$mapparams{"ScaleVec"}};
  my @Offset2 = @{$mapparams{"Offset2"}};

  for(my $d = 0 ; $d < scalar @point ; $d++) {
    $retval[$d] = ($point[$d]+$Offset1[$d])/$ScaleVec[$d]+$Offset2[$d];
  }

  return @retval;
}

