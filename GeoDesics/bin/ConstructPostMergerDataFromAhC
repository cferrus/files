#!/usr/bin/env perl
use strict;
use warnings FATAL=>'all';
use vars qw($ME $THISDIR $LAUTO $opt_h $opt_v $opt_L
            $opt_inputdir $opt_outputdir 
            $opt_contdirname
            $opt_inputdirs @InputDirs 
            $opt_decoupled
            $opt_matchtime $opt_stencil
            $opt_expdecay $opt_rotdecay $opt_transdecay $opt_vout
            $opt_rmaxhack $opt_rwidfac $opt_rwidth $opt_mapr
            $opt_njuggle $opt_ncyl $opt_autoncyl $opt_tsbounded $opt_autovout
            $opt_derivorderfvt $opt_ngrprocs
            $opt_ntotalprocs
            $opt_rminfac $opt_autorminfac $opt_rmidfac $opt_resr $opt_resl
            $opt_nopremergermap $opt_inertial $opt_hydro $opt_hdriver
            $opt_domaininput $opt_rah $opt_pid $opt_autotdamp);
use Getopt::Long;
use Carp;
use Cwd;
use File::Basename;
use List::Util qw(max min);
use Math::Trig;
# Load SpEC perl modules
use lib dirname(Cwd::abs_path(__FILE__));
use Utils;
use ComputeRequiredVout;
use SpEC;
use Machines;

#--------------\
# Help message  >
#--------------/
sub Help {
    print STDERR <<"EoF";
Usage: $ME [options] 
OPTIONS: [Defaults/current values are in brackets]
  --inputdir STRING     Location of Domain.input and SpatialCoordMap.input
                        and History files for the final segment of the plunge
                        run that you are taking over from. Default undef.
  --inputdirs GLOB      Location of History files for all plunge segments that
                        will go into the d/dt(AH) computation.
                        This is a shell glob pattern.
                        ASSUMES ALL SEGMENTS HAVE THE SAME SPATIALCOORDMAP.
                        Default undef.
  --contdirname STRING  The common AH in the inertial frame is located here,
                        relative to --inputdirs.
                        Default undef.
  --outputdir   STRING  OUTPUT directory for produced input files. The script
                        creates this directory. [$opt_outputdir]
  --matchtime DOUBLE    Time to match pre-merger and post-merger runs.
                        If not specified, takes it from the latest step  
                        in any checkpoint files it finds. Default undef.
  --stencil INT         Size of stencil for derivatives. The total number of
                        times used is stencil*2 + 1.   [$opt_stencil]

  ===Options involving maps===

  --L INT               Maximum Ylm 'L' for shape control during ringdown.
                        Also sets InitL of horizon finder to 'L'. If this
                        option is <= 0 (the default), then L is set as the
                        *minimum* L of the common AH during the inspiral, and
                        then we also set the Domain L to 'L'+4.
  --rah     DOUBLE      Default is undef.  If defined, forces rAH to
                        this value.   Otherwise sets rAH so that lambda00
                        is zero initially.
  --expdecay DOUBLE     Decay rate of expansion map.   [$opt_expdecay]
  --rotdecay DOUBLE     Decay rate of rotation map.    [$opt_rotdecay]
  --transdecay DOUBLE   Decay rate of translation map. [$opt_transdecay]
  --autotdamp           Turns on automatic tdamping in ringdown. 
                        [$opt_autotdamp]
  --vout DOUBLE         Add a (positive) outward velocity to the excision
                        boundary.  This can sometimes fix problems where the 
                        char speeds are slightly negative at the transition.
  --autovout            Determine vout automatically.
  --derivorderfvt INT   Deriv order of control systems (except for AhSpeed
                        control, which needs to be 3) [$opt_derivorderfvt]
  --tsbounded           Use 'Bounded' TimeScaleTuner where appropriate,
                        instead of 'Simple'.
  --decoupled           If true, uses the decoupled shape map.  Else uses
                        the shape map as of Nov 12 2012.  Default false.
  --pid                 Use PID controller instead of PND if derivorderfvt=2.
  --nopremergermap      If specified, assumes that the input SpatialCoordMap 
                        is the identity.
  --inertialframe STRING  Default 'Inertial'.  For hydro runs, this should be
                          'SpectralInertial'.
  --hydro               If true, writes input files for hydro domain.
  --hdriver             If true, assumes h driver.

  ===Options for creating new domain===

  --ngrprocs INT        Total number of gr processors (hydro only). 
                        [$opt_ngrprocs]
  --ntotalprocs INT     Total number of gr+hydro processors (hydro only). 
                        [$opt_ntotalprocs]
  --rminfac DOUBLE      Determines excision boundary = rAH*rminfac.
                        [$opt_rminfac].  If --autorminfac, then this is
                        this minimum allowed rminfac.
  --autorminfac         Determine rminfac automatically.  This will find
                        the smallest acceptable value, and then use the
                        greater of the auto-rminfac and the value supplied
                        with the rminfac option [$opt_rminfac].
  --rmidfac DOUBLE      Determines rmid = r_excision*rmidfac. [$opt_rmidfac]
                        At this radius, the distorion Ylm map is switched off.
  --rwidfac DOUBLE      Factor between widths of successive inner spheres. 
                        Shells will cover increasingly larger widths, until
                        the width becomes larger than --rwidth.
                        [$opt_rwidfac].
  --rwidth DOUBLE       Maximal radial width of a spherical shell [$opt_rwidth]
  --mapr    STRING      Radial map in each subdomain [$opt_mapr]
  --domainprefix STRING Reads PREFIXDomain.input files instead of
                        Domain.input files.  Default empty.
  --domaininput STRING  Instead of having this script generate a Domain.input
                        file for the ringdown, specify your own pre-prepared
                        Domain.input file by this option.
                        This Domain.input file MUST contain the tokens
                        '__Rmin__', '__Rmid__' and '__Rmax__', which this 
                        script will replace with radii that
                        it computes.  It also MUST contain the tokens '__Nr__'
                        and '__L__', which are replaced by the radial and
                        angular resolutions from --resr and --resl options. 
                        If 'DomainInput' is specified, then the options 
                        'rwidfac', and 'mapr' are ignored. 
                        Default undef.
  --resr    STRING      Radial resolution per subdomain [$opt_resr]
                        Should be formula involving '\$k', which is the level.
                        NOTE: Use single quotes so the shell does not expand
                        the dollar sign.
  --resl    STRING      'L' resolution per subdomain [$opt_resl]
                        Should be formula involving '\$k', which is the level.
                        NOTE: Use single quotes so the shell does not expand
                        the dollar sign.
  --rmaxhack DOUBLE     Normally YOU SHOULD NOT USE THIS. This decreases Rmax
                        in Domain.input *BUT NOT IN SpatialCoordMap.input*
                        for the case in which the maps at the outer boundary
                        do not agree.  Decrease is by the given amount.
                        **This option will be removed in the future.**
  --njuggle INT         Replace the innermost INT spheres with juggleballs.
  --ncyl    INT         Replace the innermost INT spheres with cylinders.
                        You can set either --njuggle or --ncyl but not both.
  --autoncyl QMAX       Sets ncyl = 1 if mass ratio is > QMAX
                        Default: QMAX = 5.9.
                        To turn off this option, choose QMAX = 0.
                        You cannot use QMAX!=0 with --njuggle or --ncyl

  ===Misc Options===

  --v                Verbose. Print extra information.
  --h                Help. Print this table.
EoF
  exit(1);
}

#----------------------------------------------------------------
# Set 'ME' as name of the executable and $THISDIR as current dir.
#----------------------------------------------------------------
$ME      = basename(__FILE__);
$THISDIR = `/bin/pwd`; chomp $THISDIR;
# We want to use $RealBin for finding executables to call using system
# calls.  But dirname(__FILE__) points to either a bin directory or a
# Support/Perl directory. If the former, then we use it.  If the
# latter, then there is always a Support/bin directory next to
# Support/Perl, and we want to use Support/bin because Support/bin
# contains things (like python scripts and SpEC executables) that are
# not in Support/Perl.  So "/../bin" does the trick for both cases.
my $RealBin = dirname(__FILE__) . "/../bin";

# Make sure ApplyObservers is called from the right place
my $MPI1 = new Machines()->GetMpiCmd(1);  #for single process execs
my $APPLYOBS1 = "$MPI1 $RealBin/ApplyObservers";
my $SURFTO1 = "$MPI1 $RealBin/SurfaceToSpatialCoordMapFiles";
my $TRAJTO1 = "$MPI1 $RealBin/TrajectoryToSpatialCoordMapFiles";

#-----------------
# Get options
#-----------------
$opt_h             = '';
$opt_v             = '';
$opt_derivorderfvt = 3;
$opt_decoupled     = undef;
$opt_tsbounded     = undef;
$opt_vout          = undef;
$opt_autovout      = undef;
$opt_inputdir      = undef;
$opt_inputdirs     = undef;
$opt_contdirname   = undef;
$opt_outputdir     = "Continuation";
$opt_matchtime     = undef;
$opt_stencil       = 3;
$opt_njuggle       = 0;
$opt_ncyl          = undef;
$opt_autoncyl      = 5.9; # This is the limiting mass ratio for autoncyl.
$opt_L             = 0;
$opt_rah           = undef;
$opt_expdecay      = 5.0;
$opt_rotdecay      = 5.0;
$opt_transdecay    = 5.0;
$opt_ngrprocs      = 12;
$opt_ntotalprocs   = 12;
$opt_rminfac       = 0.9;
$opt_autorminfac   = undef;
$opt_rmidfac       = 32.0;
$opt_rwidfac       = 1.5;
$opt_rwidth        = 20.0;
$opt_mapr          = 'Lin';
$opt_domaininput   = undef;
$opt_resr          = '10+2*$k';
$opt_resl          = '12+2*$k';
$opt_rmaxhack      = undef;
$opt_nopremergermap= undef;
$opt_autotdamp     = 1;
$opt_pid           = undef;
$opt_inertial      = "Inertial";
$opt_hydro         = undef;
$opt_hdriver       = undef;

GetOptions('h'               => \$opt_h,
           'v'               => \$opt_v,
           'pid'             => \$opt_pid,
           'decoupled'       => \$opt_decoupled,
           'tsbounded'       => \$opt_tsbounded,
           'inputdir=s'      => \$opt_inputdir,
           'inputdirs=s'     => \$opt_inputdirs,
           'contdirname=s'   => \$opt_contdirname,
           'outputdir=s'     => \$opt_outputdir,
           'matchtime=f'     => \$opt_matchtime,
           'stencil=i'       => \$opt_stencil,
           'njuggle=i'       => \$opt_njuggle,
           'ncyl=i'          => \$opt_ncyl,
           'autoncyl=f'      => \$opt_autoncyl,
           'derivorderfvt=i' => \$opt_derivorderfvt,
           'L=i'             => \$opt_L,
           'rah=f'           => \$opt_rah,
           'expdecay=f'      => \$opt_expdecay,
           'rotdecay=f'      => \$opt_rotdecay,
           'transdecay=f'    => \$opt_transdecay,
           'ngrprocs=i'      => \$opt_ngrprocs,
           'ntotalprocs=i'   => \$opt_ntotalprocs,
           'rminfac=f'       => \$opt_rminfac,
           'autorminfac'     => \$opt_autorminfac,
           'rmidfac=f'       => \$opt_rmidfac,
           'rwidfac=f'       => \$opt_rwidfac,
           'rwidth=f'        => \$opt_rwidth,
           'rmaxhack=f'      => \$opt_rmaxhack,
           'mapr=s'          => \$opt_mapr,
           'domaininput=s'   => \$opt_domaininput,
           'resr=s'          => \$opt_resr,
           'resl=s'          => \$opt_resl,
           'vout=f'          => \$opt_vout,
           'autovout'        => \$opt_autovout,
           'nopremergermap'  => \$opt_nopremergermap,
           'autotdamp'       => \$opt_autotdamp,
           'hydro'           => \$opt_hydro,
           'hdriver'         => \$opt_hdriver,
           'inertialframe=s' => \$opt_inertial,
    ) || Help(); Help() if $opt_h;

warn "Must specify --inputdir\n"   and Help() unless (defined $opt_inputdir);
warn "Must specify --inputdirs\n"  and Help() unless (defined $opt_inputdirs);
warn "Must specify --contdirname\n" and Help()
    unless (defined $opt_contdirname);


if($opt_autovout) {
  $opt_vout=undef;
}

if($opt_derivorderfvt!=2 && $opt_derivorderfvt!=3) {
    warn "--derivorderfvt must be 2 or 3" and Help();
}

# By convention, a zero opt_autoncyl means
# that the autoncyl option is disabled.
if($opt_autoncyl <= 0.0) {
  $opt_autoncyl = undef;
}

if($opt_njuggle!=0 && defined $opt_ncyl) {
    warn "--njuggle and --ncyl are incompatible" and Help();
}
if($opt_njuggle!=0 && defined $opt_autoncyl) {
    warn "--njuggle and --autoncyl are incompatible" and Help();
}
if(defined $opt_ncyl && defined $opt_autoncyl) {
    warn "--ncyl and --autoncyl are incompatible" and Help();
}

Main();
exit(0);

sub Main {
  #--------------------------------
  # Make directories absolute
  #--------------------------------
  CreateDirsIfNotThere(\$opt_outputdir);
  MakeDirectoriesAbsolute(\$opt_inputdir,\$opt_outputdir);
  foreach my $inputdir(glob "$opt_inputdirs") {
      MakeDirectoriesAbsolute(\$inputdir);
      push(@InputDirs,$inputdir);
  }

  #--------------------------------
  # Get matchtime if not specified
  # And get MatchCheckpointDir
  #--------------------------------
  my $Params;
  if(!defined $opt_matchtime) {
    ($opt_matchtime,$Params->{'MatchCheckpointDir'})
      = SpEC::FindLatestCheckpointTimeFromInputDir($opt_inputdir);
    print STDOUT "Found matchtime = $opt_matchtime\n" if($opt_v);
  } else {
    $Params->{'MatchCheckpointDir'}
      = SpEC::GetCheckpointDirectory($opt_inputdir,$opt_matchtime,1.e-10);
  }

  #-------------------------------------
  # Get the centers of the horizons
  #-------------------------------------
  if(!$opt_hydro)
  {
      GetIndividualHorizonCenters($Params);
  }

  #-------------------------------------
  # Take care of the autoncyl option
  #-------------------------------------
  if(defined $opt_autoncyl) {
    if($opt_hydro)
    {
	die "Cannot use opt_autoncyl in hydro runs; this is only used for BBH";
    }
    my $xA = $Params->{'CenterA'}; $xA =~ s/,.*//m;
    my $xB = $Params->{'CenterB'}; $xB =~ s/,.*//m;
    # poor-man's mass ratio
    my $q  = abs($xA) < abs($xB) ? abs($xB/$xA) : abs($xA/$xB);
    if($q > $opt_autoncyl) {
      $opt_ncyl = 1;
    }
  }
  
  #--------------------------------
  # Get starting chunk size
  # -------------------------------
  $Params->{'MergerChunkSize'} = GetMergerChunkSize($Params);

  #-------------------------------------
  # Get the time and step parameters.
  #-------------------------------------
  GetTimesAndStepsForAhStencil($Params);

  #------------------------
  # Set LAUTO
  #------------------------
  $LAUTO=undef;
  if($opt_L<1) {
      $LAUTO = 1;
      $opt_L = GetLmaxOfAhC($Params);
  }

  #------------------------
  # Get the Map parameters
  #------------------------
  DoesPremergerHaveExpansionMap($opt_inputdir,$Params);
  DoesPremergerHaveRotationMap($opt_inputdir,$Params);
  DoesPremergerHaveTranslationMap($opt_inputdir,$Params);
  GetCubicMapParams("$opt_inputdir/SpatialCoordMap.input",$Params);
  $Params->{'Rmax0'} = SpEC::GridOuterBoundary($opt_inputdir);
  print "Determined Rmax0 = $Params->{Rmax0}\n" if($opt_v);
  EvaluateCubicMapA($opt_inputdir,$Params->{'MatchTime'},$Params);
  EvaluateCubicMapA0($Params->{'MatchTime'},$Params);
  ComputeRmaxFromCubicParams($Params);
  GetRotationExpansionMapFnVsTimeType($opt_inputdir,$Params);

  #---------------------------------------------------
  # Compute the initial data files for the new
  # SpatialCoordMap and find auto-rminfac if selected.
  #---------------------------------------------------
  MakeInitCoordMapFiles($opt_outputdir,$Params);

  #------------------------
  # Get domain boundaries
  #------------------------
  ComputeRminRmid($Params,$opt_rminfac,$opt_rmidfac);

  #---------------------------------------------------
  # Create some input files for the Ringdown
  #---------------------------------------------------
  MakeSpatialCoordMapInputFile($opt_outputdir,$Params);
  MakeStateChangersInputFile($opt_outputdir,$Params);
  if(!$opt_hydro)
  {
    MakeCombinedStateChangersInputFile($opt_outputdir,$Params);
  }
  MakeDomainInputFile($opt_outputdir,$Params);

  #---------------------------------------------------
  # Adjust vout if requested.
  #---------------------------------------------------
  if($opt_autovout) {
    AdjustVoutAutomatically($opt_outputdir,$Params);
  }

  #---------------------------------------------------
  # Copy GaugeItems.input file
  #---------------------------------------------------
  Utils::MyCopy("$opt_inputdir/GaugeItems.input",
                "$opt_outputdir/GaugeItems.input");

  if($opt_nopremergermap) {
    # In this case, the pre-merger GaugeItems.input assumes a single frame.
    # But the post-merger GaugeItems.input needs to know about dual frames.
    my $text = Utils::ReadFile("$opt_outputdir/GaugeItems.input");
    $text    =~ s|(InertialFramePrefix\s*=\s*)[^;]*;|${1}${opt_inertial};|g;
    Utils::OverwriteFile("$opt_outputdir/GaugeItems.input", $text);
  }

  #---------------------------------------------------
  # Edit Hydro files.
  #---------------------------------------------------
  if($opt_hydro) {
      MakePreRingdownHySpatialCoordMapInputFile($opt_outputdir,$Params);
      MakeHySpatialCoordMapInputFile($opt_inputdir,$opt_outputdir,$Params);
      MakeHyInitialFunctionVsTimesInput($opt_inputdir,$opt_outputdir,$Params);
      MakeHyDomainInputFile($opt_inputdir,$opt_outputdir,$Params); #Order matters
      EditHySetupAndEvolutionInput($opt_inputdir,$opt_outputdir,$Params);
      EditHyInitialDataInput($opt_inputdir,$opt_outputdir,$Params);
      EditHyDataBoxItemsInput($opt_inputdir,$opt_outputdir,$Params);
      EditHyCommunicationInput($opt_inputdir,$opt_outputdir,$Params);
  }

  #---------------------------------------------------
  # Edit DoMultipleRuns.input file
  #---------------------------------------------------
  EditRingdownDoMultipleRuns($opt_inputdir,$opt_outputdir,$Params);

  # Identify that the script is finished.
  print "$ME: Done.\n" if($opt_v);
}

#-------------------------------------------------------------------
#-------------------------------------------------------------------
#-------------------------------------------------------------------
#-------------------------------------------------------------------
# Subroutines below
#-------------------------------------------------------------------
#-------------------------------------------------------------------
#-------------------------------------------------------------------
#-------------------------------------------------------------------

sub AdjustVoutAutomatically {
  my($destdir,$params)=@_;

  my $requiredvout = MyComputeRequiredVout($destdir,$params);

  # Previously, the requirement for vout to be positive was commented out
  # here.  However, there are other places in the code,
  # e.g. SurfaceToSpatialCoordMapFiles, that ignore negative values of
  # vout.  As a result, the effect of allowing a negative vout here is that
  # output files are inconsistent, and different classes get out of sync
  # with each other.  **This causes failed ringdowns**.
  #
  # If we really want negative vout, then SurfaceToSpatialCoordMapFiles must be
  # changed before commenting out the check here, and then negative vouts
  # must be tested before pushing.
  if($requiredvout>0.0) {
    # Cd to the dest directory.
    $opt_vout = $requiredvout;
    chdir($destdir) || die "Cannot chdir $destdir";
    MakeInitCoordMapFilesWork($destdir,$params);
    chdir($THISDIR) || die "Cannot chdir $THISDIR";
  }
}

#---------------
sub MyComputeRequiredVoutWork {
  my($destdir,$params,$CurrentL)=@_;
 
  my $tempdir  = "MyComputeRequiredVout.$$"; 
  mkdir($tempdir) || die "Cannot mkdir $tempdir";
  MakeDirectoriesAbsolute(\$tempdir);

  # Edit SpatialCoordMap.input.
  {
    my $text = Utils::ReadFile("$destdir/SpatialCoordMap.input");
    $text    =~ s|__DIR__|$destdir|g;
    $text    =~ s|__DIROLD__|$opt_inputdir|g;
    $text    =~ s/RmaxIndex\s*=\s*\d+;/RmaxIndex=1;/g;
    Utils::OverwriteFile("$tempdir/SpatialCoordMap.input", $text);
  }

  # Create new Domain.input that has only a single shell around a single
  # black hole.  
  {
    my $DomainInput;
    $DomainInput = "SubdomainStructure=
   SphericalShells3D(BaseName = Sphere;
                     Center   = 0,0,0;
                     L        = $CurrentL;
                     r-Axis   = (Extents  = 5;
                                 Maps     = Lin;
                                 IndexMap = ChebyshevGaussLobatto;
                                 Topology = I1;
                                 Bounds   = $params->{'Rmin'},
                                            2*$params->{'Rmin'};
                                );
                     );";
    # Now write domain.input
    Utils::OverwriteFile("$tempdir/GrDomain.input",
                         $DomainInput."\n");
  }

  my @CenterString=("0,0,0");
  my $cwd = cwd();
  chdir($destdir) || die "Cannot cd $destdir\n";
  my $CpVarsString = ($opt_hydro) ? "Cp-Vars" : "Cp-VarsGr";
  my @val = ComputeRequiredVout(\@CenterString,$opt_matchtime,
                                $CpVarsString,0.001,
                                $opt_inputdir,$opt_inputdir,
                                $params->{'MatchCheckpointDir'},
                                undef,undef,
                                "$tempdir/SpatialCoordMap.input",
                                "$tempdir/GrDomain.input");
  chdir($cwd) || die "Cannot cd $cwd\n";

  unlink "$tempdir/SpatialCoordMap.input" || die;
  unlink "$tempdir/GrDomain.input" || die;
  rmdir $tempdir || die "Cannot rmdir $tempdir";
  return $val[0];
}

sub MyComputeRequiredVout {
  my($destdir,$params)=@_;

  # Iterate vout computation until convergence.
  my $epsrel   = 0.01;   # relative error
  my $epsabs   = 0.0001; # absolute error
  my $CurrentL = 20;
  my $LIncrement = 6; # Increase L by this amount each iteration.
  my $MaxIts   = 20;
  my $vout = MyComputeRequiredVoutWork($destdir,$params,$CurrentL);
  for(my $iter = 0; $iter < $MaxIts; ++$iter) {
    print "Vout=$vout at iter $iter, L=$CurrentL\n" if ($opt_v);
    $CurrentL = $CurrentL+$LIncrement;
    my $oldvout = $vout;
    $vout = MyComputeRequiredVoutWork($destdir,$params,$CurrentL);
    if(abs($oldvout-$vout) < $epsrel*(abs($oldvout)+abs($vout))
       ||
       abs($oldvout-$vout) < $epsabs) {
      return $vout;
    }
  }
  die "Vout doesn't converge after $MaxIts iterations.";
}

sub AutoRminFacInnerIteration {
  my($destdir, $params, $newrminfac, $RminfacEPS, $CurrentL)=@_;
  local $_;

  # Set up temporary ApplyObservers file.
  my $tempfile = "ApplyObserversInnerIter.$$.input";

  my $Converged = 0;
  my $RminfacMAXITS = 20;
  my $FirstIteration = 1;
  my $it = 0;

  while (!$Converged and $it < $RminfacMAXITS) {

    # Create init-files using the current rminfac
    $opt_rminfac = $newrminfac;
    MakeInitCoordMapFilesWork($destdir,$params);
    
    # Create Domain and SpatialCoordMap input files.
    # We are in $destdir.
    
    ComputeRminRmid($params,$opt_rminfac,$opt_rmidfac);
    my $Rmin  = $params->{'Rmin'};
    my $Rmid  = $params->{'Rmid'};
    my $Rmax  = $params->{'Rmax'};
    
    MakeSpatialCoordMapInputFile($opt_outputdir,$params,
                                 "SpatialCoordMapInner.input");
    MakeDomainInputFile($opt_outputdir,$params,
                        "GrDomainInner.input");
    
    # Replace the following tokens in domain.input and spatialcoordmap.input
    # SpatialCoordMap.input: __DIR__ and __DIROLD__
    # Domain.input: __L__ and __Nr__
    
    my $text = Utils::ReadFile("$destdir/SpatialCoordMapInner.input");
    $text =~ s|__DIR__|$destdir|g;
    $text =~ s|__DIROLD__|$opt_inputdir|g;
    
    # Overwrite file
    Utils::OverwriteFile("$destdir/SpatialCoordMapInner.input", $text);
    
    # Note: these resolutions dont matter, but there needs to be something
    # for ApplyObservers to parse it correctly.
    $text = Utils::ReadFile("$destdir/GrDomainInner.input");
    $text =~ s|__L__|30|g;
    $text =~ s|__Nr__|14|g;
    
    # Overwrite file
    Utils::OverwriteFile("$destdir/GrDomainInner.input", 
                         $text);
    
    # Set up ApplyObservers input to transform surfaces to
    # the ringdown grid frame and compute distances.
    
    my $ApplyObsInput =
        "      DataBoxItems =
           ReadFromFile(File=SpatialCoordMapInner.input),
           Domain
           (Items=
            ReadSurfaceInfoFromFile(FileName=InertialExcA_L${CurrentL}Coefs.dat;
                                    Output=InertialExcA;
                                    TakeTimeFromDataBox=yes;),
            ReadSurfaceInfoFromFile(FileName=InertialExcB_L${CurrentL}Coefs.dat;
                                    Output=InertialExcB;
                                    TakeTimeFromDataBox=yes;),
            CoordMappedSurfaceInfo(Input=InertialExcA;
                                   Output=RingdownGridExcA;
                                   MapPrefix=GridTo${opt_inertial};
                                   MapGoesToOutputFrame=false;),
            CoordMappedSurfaceInfo(Input=InertialExcB;
                                   Output=RingdownGridExcB;
                                   MapPrefix=GridTo${opt_inertial};
                                   MapGoesToOutputFrame=false;),
            DistanceFromPointToSurfaceInfo(Output=DistanceA;
                                           SurfaceInfo=RingdownGridExcA;
                                           Op=Max;
                                           Verbose=no;
                                           Point=0,0,0;
                                           SpatialCoordMapGridToSurfaceFrame=;
                                           ),
            DistanceFromPointToSurfaceInfo(Output=DistanceB;
                                           SurfaceInfo=RingdownGridExcB;
                                           Op=Max;
                                           Verbose=no;
                                           Point=0,0,0;
                                           SpatialCoordMapGridToSurfaceFrame=;
                                           ),
            );
      Observers=
           ObserveDoubles(Input=DistanceA,DistanceB;
                          Filename=Distances.txt);";
    # Print temp file.
    Utils::OverwriteFile($tempfile, $ApplyObsInput);
    
    # Run ApplyObservers with -E to force evolution mode.
    {
      my $matchtime=$params->{'MatchTime'};
      Utils::System("$APPLYOBS1 -domaininput "
                    . "GrDomainInner.input "
                    . " -NoDomainHistory -E " 
                    . "-UseTimes=$matchtime $tempfile", $opt_v);
      # Clean up.
      unlink("GrDomainInner.input",
             "SpatialCoordMapInner.input");
    }
    
    # Read distances from Distances.txt
    my $distanceA=undef;
    my $distanceB=undef;
    
    my @text = Utils::ReadFile("Distances.txt");
    foreach(@text) {
      next if(/^\s*\#/); # skip comments
      next if(/^\s*$/);  # skip empty lines
      my @columns = split;
      die "wrong number of columns" unless (scalar(@columns)==3);
      $distanceA = $columns[1];
      $distanceB = $columns[2];
    }
    
    print "Found distanceA = $distanceA and distanceB = $distanceB\n"
        if ($opt_v);
    my $maxdistance = ($distanceA > $distanceB? $distanceA : $distanceB);
    
    die "RAh is not yet defined" unless (defined $params->{'RAh'});
    $newrminfac = $maxdistance/$params->{'RAh'};

    # We have just computed the *minimum* value of rminfac so that the
    # new single-domain excision boundary is barely outside the AhA and
    # AhB excision boundaries (so that we can interpolate from the old
    # two-domain grid onto the new one-domain grid). 
    # However, we don't want the new excision boundary to be barely
    # touching the old one, especially for high mass ratio where there
    # is a lot of structure near the smaller hole.  So here we adjust
    # $newrminfac so that it is 3/4 of the way between the minimum
    # possible value and the excision boundary.
    my $adjustment = 0.25;
    $newrminfac = 1.0-$adjustment*(1.0-$newrminfac);
    
    $it++;
    print "Found new rminfac $newrminfac after iteration $it\n" if ($opt_v);
    
    if (abs($opt_rminfac - $newrminfac) < 0.5*$RminfacEPS) {
      $Converged = 1;
    }
    if ($FirstIteration) {
      $FirstIteration = 0;
      $Converged = 0;
    }
      
    # Clean up for next iteration.
    unlink(glob("Init*")) || die;

  } # end while (!$Converged && $it < $RminfacMAXITS)

  # Check how we exited the while loop
  if ($Converged) {
    if ($newrminfac > 1+$RminfacEPS) {
      die "ERROR: rminfac converged to a number greater than one.\n".
          "Either your common horizon does not actually contain the\n".
          "excised regions, or there is some problem with the ringdown\n".
          "mappings or with the autorminfac routine.";
    } elsif ($newrminfac > 1.0-3*$RminfacEPS) {
      die "ERROR: rminfac converged to a number very close to one.\n".
          "Either the precision of this routine should be increased, or\n".
          "perhaps you should run the plunge a bit longer to increase the\n".
          "distance between the excision regions and the common horizon.\n";
    } elsif ($newrminfac <= 0) {
      die "ERROR: rminfac converged to a number <= 0 ???";
    } else {
      print "rminfac successfully converged!\n" if ($opt_v);
    }
  } elsif ($it >= $RminfacMAXITS) {
    die "rminfac failed to converged within $RminfacMAXITS iterations\n";
  }

  return $newrminfac;
}

sub AutoRminFac {
  my($destdir, $params)=@_;
  local $_;
  # Here we determine the smallest acceptable rminfac automatically.
  # We do this by transforming the excision A and B surfaces from the
  # merger grid frame at the matchtime to the ringdown grid frame.  
  # Then we find the maximum distance of these surfaces from the 
  # ringdown grid origin, which gives the minimum acceptable excision
  # radius for the ringdown.  
  # Because the map from the inertial to the ringdown grid frame actually 
  # depends on the chosen ringdown excision radius, we must iterate
  # this procedure until it has suitably converged.
  
  # As an optimization, for the first iteration we use the supplied
  # (or default) rminfac, i.e. the minimum allowed, as a starting guess.
  # If it works, then go with that.  If not, then keep iterating from there.
    
  my $original_rminfac = $opt_rminfac;
  my $newrminfac = $opt_rminfac;
  
  print "Now determining rminfac automatically...\n" if ($opt_v);
  
  my $CenterA = $params->{'CenterA'};
  my $CenterB = $params->{'CenterB'};

  # xA and xB are the x coords of CenterA and CenterB.
  my $xA = $CenterA; $xA =~ s/,.*//m; print "found xA = $xA\n";
  my $xB = $CenterB; $xB =~ s/,.*//m; print "found xB = $xB\n";
  # Poor-man's mass ratio.
  my $q  = abs($xA) < abs($xB) ? abs($xB/$xA) : abs($xA/$xB);
  print "found approximate mass ratio = $q\n";

  my $RminfacEPS = 1.e-3/$q; # Want more accuracy for higher mass ratio.


  my $CurrentL  = 20;
  my $LIncrement=  6; # L increases by this amount each iteration.
  my $MaxIts    = 10;
  my $FirstIter = 1;
  my $iter      = 0;
  my $Converged = 0;

  while (!$Converged and $iter < $MaxIts) {
    if ($opt_v) {
      print "Outer rminfac iteration with L=$CurrentL, rminfac=$newrminfac\n";
    }
    
    # set up ApplyObservers file to find rExcAB and
    # transform surfaces to the inertial frame
    my $ApplyObsInput =
        "      DataBoxItems =
           ReadFromFile(File=SpatialCoordMap.input),
           Domain
           (Items=
            RadiusOfInnerSphericalBoundary(Center=$CenterA;
                                           Output=rExcA;),
            RadiusOfInnerSphericalBoundary(Center=$CenterB;
                                           Output=rExcB;),
            CoordMappedSurfaceInfo(Input=ExcA;
                                   Output=InertialExcA;
                                   MapPrefix=GridTo${opt_inertial};
                                   MapGoesToOutputFrame=yes;),
            CoordMappedSurfaceInfo(Input=ExcB;
                                   Output=InertialExcB;
                                   MapPrefix=GridTo${opt_inertial};
                                   MapGoesToOutputFrame=yes;),
            ConstVectorOfDouble(Output=CenterA;
                                Components=$CenterA;),
            ConstVectorOfDouble(Output=CenterB;
                                Components=$CenterB;),
            SphereSurfaceInfo(Center=CenterA;
                              L=$CurrentL;
                              Radius=rExcA;
                              Output=ExcA;),
            SphereSurfaceInfo(Center=CenterB;
                              L=$CurrentL;
                              Radius=rExcB;
                              Output=ExcB;),
           );
   Observers =
           ObserveDoubles(Input=rExcA,rExcB;
                          Filename=rExcAB.txt),
           SurfaceInfo(Input=InertialExcA;
                       OutputCoefficients=yes;),
           SurfaceInfo(Input=InertialExcB;
                       OutputCoefficients=yes;);";
    
    # Set up temporary ApplyObservers file.
    my $tempfile = "ApplyObservers.$$.input";
  
    # Print temp file.
    Utils::OverwriteFile($tempfile, $ApplyObsInput);
  
    # Run ApplyObservers
    {
      my $matchtime=$params->{'MatchTime'};
      Utils::System("$APPLYOBS1 -domaininput GrDomain.input "
                    . "-UseTimes=$matchtime $tempfile", $opt_v);
    }

    my $oldrminfac = $newrminfac;
    $newrminfac = AutoRminFacInnerIteration($destdir,$params,
                                            $newrminfac,$RminfacEPS,$CurrentL);

    if($FirstIter) {
      # Always do more than one iteration so we can check
      # convergence.
      $FirstIter = 0;
    } elsif(abs($oldrminfac-$newrminfac) < 0.5*$RminfacEPS) {
      $Converged = 1;
    }

    $iter++;
    $CurrentL = $CurrentL+$LIncrement;
  } # end while (!$Converged and $iter < $MaxIts)
  if($iter>=$MaxIts) {
    die "Outer rminfac failed to converged within $MaxIts iterations\n";
  }
  
  # Decide on which rminfac to use.  round and add a bit as safety,
  # and compare to original_rminfac.
  my $SafeRminfac = sprintf("%d",$newrminfac/$RminfacEPS);
  $SafeRminfac *= $RminfacEPS;
  $SafeRminfac += $RminfacEPS;
  if ($SafeRminfac - $newrminfac < 0.5*$RminfacEPS) {
    $SafeRminfac += $RminfacEPS;
  }
  
  $opt_rminfac = $original_rminfac > $SafeRminfac? $original_rminfac :
      $SafeRminfac;
  
  print "Will use rminfac = $opt_rminfac\n" if ($opt_v);
}

# Assumes $destdir already exists
sub MakeIntermediateFrameAhCFiles {
  my($srcdir,$destdir,$ahcfilename,$params)=@_;
  local $_;

  # Here we create an 'intermediate' frame, which we can think of as
  # the ringdown distorted frame.
  # This frame is defined as the Inertial frame put through the
  # RINGDOWN inverse (rotation+scaling+translation) map.
  # If the new rotation+scaling+translation map were the same as the
  # plunge DistortedToInertial map, then this intermediate frame
  # would be the same as the plunge distorted frame.  
  # But the ringdown rotation+scaling+translation map is different than the
  # plunge kinematical map, because
  #  1) The ringdown expansion map is the identity in the near-field region
  #     and matches the plunge expansion map only far from the hole.
  #  2) The ringdown rotation and scaling maps match to the plunge ones
  #     only at the transition time, and are rolled to constant after this.
  #  3) There is no skew map in the ringdown (not needed)
  #  4) The ringdown translation map is discontinuous and different than
  #     the plunge one because it is tracking a different center.
  #
  # So we compute AhC in this new ringdown distorted frame at several
  # times (using the already-computed Inertial AhC and the map).  We will also
  # time-differentiate this AhC.  In this way, the coefficients of the
  # computed AhC and it's time derivatives will be (except for a minus sign, 
  # and except for an adjustment of the l=m=0 coefficient) exactly
  # the coefficients of the ringdown GridToDistorted map assuming a spherical
  # excision boundary in the ringdown grid frame.
  #
  # We also compute the center of the AhC at each time so that we can
  # correct the translation map later...

  my $cwd = cwd();
  chdir($destdir) || die "Cannot chdir $destdir";

  # Copy files from src directory.
  my @filestocleanlater = CopyFilesFromSrcDir($srcdir);

  # Write input file
  my %maps                  = KinematicalMaps($params);
  my $HolderAdder           = ConstructHolderAdder(%maps);
  my $IntermediateMapHolder = MapHolder(%maps);
  
  my $fnvstime = IntermediateKinematicalMapFnVsTimeString($params,
                                                          $opt_inputdir . "/",
                                                          $srcdir  . "/",
                                                          "BOGUS",
                                                          1);
  
  my @times=TimesThatExistInAhFile($ahcfilename,@{$params->{'DerivTimes'}});
  
  print STDOUT "Entered here, srcdir = $srcdir\n";
  
  print STDOUT "Times = @times\n";
  
  unless(scalar(@times)) {
    # If no times, then don't bother.
    unlink(@filestocleanlater);
    chdir($cwd) || die "Cannot chdir $cwd";
    return;
  }
  
  print STDOUT "Continuing here, srcdir = $srcdir\n";
  
  
  my $ApplyObsInput =
      "DataBoxItems = 
    Subdomain(Items =
              SpatialCoordMap::InvMappedCoords
              (MapPrefix = IntermediateToInertial;
               Input     = GridTo${opt_inertial}::MappedCoords;
               Output    = IntermediateCoords),
    ),
    Domain(Items=
           $HolderAdder,
           SpatialCoordMapItems
           (Prefix     =IntermediateTo${opt_inertial};
            InputCoords=IntermediateCoords;
            Map = $IntermediateMapHolder;
           ),";
  if($fnvstime ne "") {
    $ApplyObsInput .= "\n$fnvstime,";
  }
  
  $ApplyObsInput .= "
           ReadSurfaceInfoFromFile(Output   = AhC;
                                   FileName = $ahcfilename;
                                   MaxL     = $opt_L;
                                   TakeTimeFromDataBox=yes;
           ),
           SurfaceInfoCenter(Input =AhCIntermediateFrame;
                             Output=AhCIntermediateFrameCenter;),
           CoordMappedSurfaceInfo(Input               = AhC;
                                  Output              = AhCIntermediateFrame;
                                  Recenter            = true;
                                  RecenterTol         = 1.e-8;
                                  MapPrefix           = IntermediateTo${opt_inertial};
                                  MapGoesToOutputFrame= false;),";
  if($opt_nopremergermap) {
    $ApplyObsInput .= "
           SpatialCoordMapItems
           (Prefix     =GridTo${opt_inertial};
            InputCoords=<<Grid>>;
            Map        =CoordToSpatialCoordMap(CoordMap=Identity(Dim=3));
           ),
    );";
  } else {
    $ApplyObsInput .= "
    ),
    ReadFromFile(File=SpatialCoordMap.input);";
  }
  $ApplyObsInput .= "
Observers=
    MappedCoords(InputFromDataBox   = AhCIntermediateFrameCenter;
                 SpatialCoordMap    = IntermediateTo${opt_inertial}::SpatialCoordMap; 
                 UseInverseMap      = false;
                 Filename           = AhC_NewInertialCenter.dat),
    SurfaceInfo(Input               = AhCIntermediateFrame;
                OutputCoefficients  = yes);";
  
  # Set up temporary ApplyObservers file.
  my $tempfile = "ApplyObservers.$$.input";
  
  # Print temp file.
  Utils::OverwriteFile($tempfile, $ApplyObsInput);
  
  # Run ApplyObservers
  {
    my $times=join(',',@times);
    my $opts ="-UseTimes=$times -domaininput=GrDomain.input";
    Utils::System("$APPLYOBS1 $opts $tempfile", $opt_v);
  }

  # Concatenate AhC files to prior $cwd.
  foreach my $cpfile(glob "AhC*.dat") {
    next unless -f "$cpfile";
    push(@filestocleanlater,$cpfile);
    my $outfile = "$cwd/$cpfile";
    die "Infinite loop" if ($cwd eq $destdir);
    open(OUTFILE,">>$outfile") || die "Cannot open $outfile";
    open(INFILE,"<$cpfile") || die "Cannot open $cpfile";
    while($_=<INFILE>) {
      print OUTFILE $_;
    }
    close(INFILE);
    close(OUTFILE);
  }

  # Clean up
  unlink(@filestocleanlater,$tempfile);
  chdir($cwd) || die "Cannot chdir $cwd";
}

#---------------
# Makes the new Init*.txt files for the SpatialCoordMap
sub MakeInitCoordMapFiles {
  my($destdir,$params)=@_;
  local $_;

  my %files;
  foreach my $inputdir (@InputDirs) {
    foreach my $file (glob "$inputdir/$opt_contdirname,AhC_*Coefs.dat") {
      if (-f $file) {
        push(@{$files{$inputdir}},$file);
      }
    }
  }
  if(scalar(keys %files)<=0) {
    foreach my $inputdir (@InputDirs) {
      my @files;
      foreach my $file (glob "$inputdir/$opt_contdirname/AhC*Coefs.dat") {
        if (-f $file) {
          push(@{$files{$inputdir}},$file);
        }
      }
    }
  }
  
  # Cd to the dest directory.
  chdir($destdir) || die "Cannot chdir $destdir";

  # Make the intermediate frame files.
  {
    my $indx = "00";
    foreach my $inputdir (sort keys %files) {
      foreach my $file (@{$files{$inputdir}}) {
        my $tempdir = "MakeAhCFiles.${indx}.$$";  ++$indx;
        print STDOUT "Making $tempdir\n";
        mkdir($tempdir) || die "Cannot mkdir $tempdir";
        MakeDirectoriesAbsolute(\$tempdir);
        MakeIntermediateFrameAhCFiles($inputdir,$tempdir,$file,$params);
        rmdir($tempdir) || die "Cannot rmdir $tempdir";
      }
    }
  }

  my @filestocleanlater = CopyFilesFromInputDir();

  if (defined $opt_autorminfac) {
    AutoRminFac($destdir,$params);
  }

  # Now we have the $opt_rminfac we want to use (auto or not),
  # so we can make the real Init files.
  MakeInitCoordMapFilesWork($destdir,$params);

  # Clean up
  unlink(@filestocleanlater) || die;
  chdir($THISDIR) || die "Cannot chdir $THISDIR";
}

#---------------
sub MakeInitCoordMapFilesWork{
  my($destdir,$params)=@_;
  local $_;
  # we should already be in $destdir

  # Now we have AhC in the intermediate frame (the ringdown Distorted frame)
  # at various times.  We now find the coefficients of this AhC and the
  # time derivatives of the coefficients, and these will be put into
  # the Init* files that describe the ringdown GridToDistorted map.

  {
    # First remove old Init* files if they exist
    foreach my $file (glob "Init-*.txt") {
      if(-f "$file") {
        unlink($file) || die "Cannot unlink $file\n";
      }
    }

    # Now differentiate to get Init* files.
    # Note that this will set rAH so that the l=m=0 coefficient of the
    # ringdown distortion map is zero.
    {
      my @newfiles= glob("AhCIntermediateFrame_*Coefs.dat");
      my $opt     = (defined($opt_rah) ? "-rah $opt_rah" : "");
      $opt       .= " -rminfac $opt_rminfac";    
      $opt       .= " -rmaxfac " . $opt_rminfac*$opt_rmidfac;
      $opt       .= " -V=$opt_vout " if(defined $opt_vout);
      if(defined $opt_decoupled) {
        $opt       .= " -d ";
      } else {
        $opt       .= " -p ";
      }
      my $time    = sprintf("%24.16e",$params->{'MatchTime'});
      Utils::System("$SURFTO1 $opt -l "
                    ."$opt_L -s $opt_stencil"
                    ." -o $opt_stencil -T $time @newfiles", $opt_v);
    }

    # Read rAH from Init-GridParams.txt
    {
      open(INFILE,"<Init-GridParams.txt")or die"Cant open Init-GridParams.txt";
      my $found=undef;
      while(my $line=<INFILE>) {
        if($line =~ m/rAH\s*=\s*([^;]+);/) {
          $params->{'RAh'} = sprintf("%20.17f",$1);
          $found=1;
          last;
        }
      }
      die "Cannot read rAH" unless $found;
      close(INFILE) or die;
    }

    # Construct Init-FuncTransSingleHole.txt
    # The center of the AH in the intermediate frame is NOT the origin
    # (this is the case whether or not you say Recenter=true), but the
    # distortion map does its distortion about the origin.
    # Possible ways to account for this:
    #  1) Put a translation map before the distortion map.
    #  2) Change the center of the distortion map.  (then we need to live with
    #     this during the ringdown).
    #  3) Correct the current translation map so that the excision boundary
    #     maps to the correct place.
    # We choose 3).  The idea is that the horizon can be written as
    # x^ibar_AH = x^ibar_AHc + Sum(Slm Ylm) n^ibar(theta,phi)
    # where n^ibar is the direction unit vector in the (theta,phi) direction,
    # and ibar is the index corresponding to the intermediate frame.
    # Now x^i = T0^i + M^i_ibar x^ibar
    # where T0^i is the current translation map, and M^i_ibar is 
    # scaling+rotation.
    # Thus
    # x^i_AH = T0^i + M^i_ibar x^ibar_AH
    #        = T0^i + M^i_ibar x^ibar_AHc + M^i_ibar Sum(Slm Ylm) n^ibar
    # Therefore if you define a new translation map
    # T^i = T0^i + M^i_ibar x^ibar_AHc (that is, you define T^i to be the
    # same as x^i_AHc), then you can rewrite the relationship as
    # x^i_AH = T^i + M^i_ibar Sum(Slm Ylm) n^ibar
    # Therefore we use a new map
    # x^i = T^i + M^i_ibar x^itilde  where x^itilde is a new coordinate where
    # x^itilde_AHc = 0 and the coefficients of the AH in the x^itilde frame
    # can be used unchanged (except for a minus sign) in the distortion map
    # that connects x^igrid and x^itilde.
    {
      my $time    = sprintf("%24.16e",$params->{'MatchTime'});
      Utils::System("$TRAJTO1 -s $opt_stencil -T $time" .
                    " -N -o $opt_stencil AhC_NewInertialCenter.dat", $opt_v);
      rename("Init-FuncTrans.txt","Init-FuncTransSingleHole.txt") || die;
    }
  } # end of if($opt_oldmapping) else
}

#-------------------------------------------------------------------
#-------------------------------------------------------------------
# Routines that *write* input files.
#-------------------------------------------------------------------
#-------------------------------------------------------------------


sub MakeHyDomainInputFile {
  my($inputdir,$destdir,$params)=@_;

  my $dest  = "$destdir/HyDomain.input";

  # We'll build a cubical grid in the new hydro grid frame that                                                     
  # covers a sphere of radius 20km (13.56 in code units) in the                                                     
  # inertial frame.                                                                                                 
  # First, set list of points on that sphere.                                                                       
  my $FineGridSize = 13.56;
  my $points="(";
  {
      $points .= "(" . $FineGridSize . ",0,0),";
      $points .= "(-" . $FineGridSize . ",0,0),";
      $points .= "(0," . $FineGridSize . ",0),";
      $points .= "(0,-" . $FineGridSize . ",0),";
      $points .= "(0,0," . $FineGridSize . "),";
      $points .= "(0,0,-" . $FineGridSize . "),";
  }
  $points .= ")";

  # Run ApplyObservers to get points in new HyGrid frame                                                            
  {
    # Set up temporary ApplyObservers file.                                                                         
    my $tempfile = "$destdir/ApplyObservers.$$.input";

    my $ApplyObsInput = "                                                                                           
        DataBoxItems =                                                                                              
          ReadFromFile(File=$destdir/HySpatialCoordMap.input),                                                      
          # These FunctionVsTimes are needed for the initial data.                                                  
          # For the evolution, they are linked from the Gr DataBox.                                                 
          ReadFromFile(File=$destdir/HyInitialFunctionVsTimes.input);                                               
        Observers    =                                                                                              
          MappedCoords                                                                                              
             (Input          =$points;                                                                              
              SpatialCoordMap=GridToInertialFD::SpatialCoordMap;                                                    
              UseInverseMap  =true;                                                                                 
              Filename       =$destdir/HyCornerPointsNewGridFrame.dat;                                              
             );";

    # Print temp file.                                                                                              
    Utils::OverwriteFile($tempfile, $ApplyObsInput);
    # Run ApplyObservers                                                                                            
    {
	my $matchtime=$params->{'MatchTime'};
      # Don't forget the -E.                                                                                        
	my $opts = "-E -UseTimes=$matchtime ";
	$opts   .= "-domaininput=$inputdir/HyDomain.input"; # Domain not used.                                        
	Utils::System("$APPLYOBS1 $opts $tempfile",$opt_v);
    }

    # Clean up                                                                                                      
    unlink($tempfile) || die;
  }
  # Read the file to get the new bounds, as a bounding box.                                                               
  {
    my $text = Utils::ReadFile("$destdir/HyCornerPointsNewGridFrame.dat");
    $text    =~ s/#.*$//mg; # Remove comments                                                                             
    $text    =~ s/^\s*//mg; # Remove initial whitespace                                                                   
    my @pts  = split(/\s+/,$text);
    shift(@pts); # Discard the time.                                                                                      
    die "Oops: pts is @pts, last element $#pts" unless ($#pts==17);
    my $rad_max = 0.0;
    foreach my $x (1..6) {
      my $rad = 0.0;
      foreach my $y (1..3) {
        $x = shift(@pts);
	$rad = $rad + $x*$x;
      }
      $rad = sqrt($rad);
      if($rad>$rad_max)
      {
        $rad_max=$rad;
      }
    }
    print "Request inscribed sphere of radius $rad_max on hydro fine grid\n";
    # Clean up                                                                                                            
    unlink("$destdir/HyCornerPointsNewGridFrame.dat") || die;
    # Write new HyDomain.input, using 2 levels of refinements                                                             
    my $newdomainstring = "HistoryFile=<<NONE>>;\n";
    $newdomainstring .= "\n";
    $newdomainstring .= "SubdomainStructure =\n";
    $newdomainstring .= "PerimBlocks(BaseName = Interval-Lev1-;\n";
    foreach my $d ("x","y","z"){
      $newdomainstring .= "  $d-Axis = (\n";
      $newdomainstring .= "            Extents = 201;\n";
      $newdomainstring .= "            Bounds  = -$rad_max,$rad_max;\n";
      $newdomainstring .= "            SplitIntervals = 8;\n";
      $newdomainstring .= "            Maps     = Lin;\n";
      $newdomainstring .= "            IndexMap = Uniform;\n";
      $newdomainstring .= "            Topology = I1;\n";
      $newdomainstring .= "            GhostZones = 3;\n";
      $newdomainstring .= "            GhostZonesOnBoundary = true;\n";
      $newdomainstring .= "            Centering = Cell;\n";
      $newdomainstring .= "            );\n";
    }
    $newdomainstring .= "),\n";
    $newdomainstring .= "PerimBlocks(BaseName = Interval-Lev0-;\n";
    $rad_max*=2;
    foreach my $d ("x","y","z"){
      $newdomainstring .= "  $d-Axis = (\n";
      $newdomainstring .= "            Extents = 201;\n";
      $newdomainstring .= "            Bounds  = -$rad_max,$rad_max;\n";
      $newdomainstring .= "            SplitIntervals = 8;\n";
      $newdomainstring .= "            Maps     = Lin;\n";
      $newdomainstring .= "            IndexMap = Uniform;\n";
      $newdomainstring .= "            Topology = I1;\n";
      $newdomainstring .= "            GhostZones = 3;\n";
      $newdomainstring .= "            GhostZonesOnBoundary = true;\n";
      $newdomainstring .= "            Centering = Cell;\n";
      $newdomainstring .= "            );\n";
    }
    $newdomainstring .= "  SkipTheseSubdomains=";
    foreach my $x (2..5){
      foreach my $y (2..5){
        foreach my $z (2..5){
	  $newdomainstring .= "Interval-Lev0-$x.$y.$z,"
	}
      }
    }
    $newdomainstring .= ";\n);\n";
    Utils::OverwriteFile($dest, $newdomainstring);
  }
}

sub EditHyDataBoxItemsInput {
  my($inputdir,$destdir,$params)=@_;

  my $src   = "$THISDIR/HyDataBoxItems.input";
  my $dest  = "$destdir/HyDataBoxItems.input";
  my $text  = Utils::ReadFile($src);

  # Remove fake ExcisionMask
  our $bal;  $bal = qr/\((?:(?>[^()]+)|(??{$bal}))*\)/;
  while($text =~ m/EvaluateScalarFormula\s*${bal}\s*,/sg) {
    my $dum = $&;
    if($dum =~ m/Output\s*=\s*ExcisionMask/s) {
      unless($text =~ s|\Q$dum\E||s) {
        die "$ME: Cannot remove ExcisionMask from $dest";
      }
    }
  }
  Utils::OverwriteFile($dest, $text);
}


sub EditHyInitialDataInput {
  my($inputdir,$destdir,$params)=@_;

  my $src   = "$THISDIR/HyInitialData.input";
  my $dest  = "$destdir/HyInitialData.input";
  my $text  = Utils::ReadFile($src);

  $text     =~ s/__SpatialCoordMapDir__/$destdir/mg;

  Utils::OverwriteFile($dest, $text);
}

sub EditHyEvolutionInput {
  my($inputdir,$destdir,$params)=@_;

  # Read DomainSymmetry string from pre-ringdown Evolution.input,
  # insert it into the file from post-ringdown Evolution.input, 
  # and put it in the destination dir.
  my $src   = "$inputdir/Evolution.input";
  my $dest1 = "$THISDIR/Evolution.input";
  my $dest  = "$destdir/Evolution.input";
  my $dsym  = undef;
  {
    my $text = Utils::ReadFile($src);
    $text    =~ s|#.*$||mg;
    while($text =~ m|^\s*DomainSymmetry\s*=\s*([^;]+;)|gm) {
      if(defined $dsym) {
        die "Two DomainSymmetry options in $src: $dsym and $1\n";
      } else {
        $dsym=$1;
      }
    }
  }
  die "Cannot find DomainSymmetry option in $src\n" unless defined $dsym;
  my $text = Utils::ReadFile($dest1);
  $text    =~ s|^(\s*DomainSymmetry\s*=\s*)[^;]+;|$1$dsym|mg;
  Utils::OverwriteFile($dest,$text);
}

sub EditHyCommunicationInput {
  my($inputdir,$destdir,$params)=@_;

  my $src   = "$inputdir/Communication.input";
  my $dest  = "$destdir/Communication.input";
  my $text  = Utils::ReadFile($src);

  my $Link12 = "ExcisionBoundaryRadiusSpectralGrid,LambdaFactor,
  LambdaFactor0";
  {
    my $userotation       = $params->{'UseRotationMap'};
    my $useexpansion      = $params->{'UseExpansionMap'};
    my $translation       = $params->{'UseTranslationMap'};
    if($userotation eq 'PitchAndYaw') {
      $Link12 .= ",PitchAndYawSettle";
    } elsif($userotation eq 'QuaternionRotInv') {
      $Link12 .= ",QuatRotMatrixSettle";
    } elsif($userotation eq 'QuaternionFvT') {
      $Link12 .= ",QuaternionSettle";
    } elsif($userotation eq 'NoHistory') {
      $Link12 .= ",$params->{'RotationMapFvTType'}Settle";
    } elsif($userotation ne "None") {
      die "Don't understand userotation='",$userotation,"'";
    }
    if($useexpansion ne "None") {
      $Link12 .= ",ExpansionFactorSettle";
      if(defined $params->{'ExpansionFactorA0FnVsTime'}) {
        $Link12 .= ",ExpansionFactorA0Settle";
      }
    }
    if($translation) {
      $Link12 .= ",TransSingleHole";
    }
  }

  my $Link21 = "";

  $text =~ s/CappedPolynomial/ExcisionWENO5/mg;
  $text =~ s/FarthestFromBoundary\(\)/FarthestFromBoundary\(TerminateOnPointsOutside=false;\)/mg;
  $text =~ s/(ItemsToLinkFromBox1ToBox2\s*=\s*)[^;]+;/$1$Link12;/s;
  $text =~ s/(ItemsToLinkFromBox2ToBox1\s*=\s*)[^;]+;/$1$Link21;/s;

  # Add HydroMapStringName unless it is already there
  unless($text =~ m/HydroMapStringName\s*=\s*/) {
    $text .= "\nHydroMapStringName=;\n";
  }

  Utils::OverwriteFile($dest, $text);
}

sub EditHySetupAndEvolutionInput {
  my($inputdir,$destdir,$params)=@_;

  my $src   = "$THISDIR/HySetupAndEvolution.input";
  my $dest  = "$destdir/HySetupAndEvolution.input";
  my $text  = Utils::ReadFile($src);

  # add spatial coord map and excision stuff at the beginning
  my $newstuff="
   ReadFromFile(File=HySpatialCoordMap.input),
   # Excision stuff
   Subdomain(Items =
    SphericalMask(Output    =ExcisionMask;
                  RadiusName=ExcisionBoundaryRadiusSpectralGrid;
                  Center    =0,0,0;
                  Invert    =false;
                  Map       =MapBetweenDomains::SpatialCoordMap;
                  ),
    # ToDo:  Set an outer excision region too?
    FaceMaskFromCellMask(CellMask=ExcisionMask),
    ExcisionNeighborMask(Output  =ExcisionMaskNeighbors;)
   ),
";
  $text =~ s/(DataBoxItems\s*=)/${1}$newstuff/m;

  # Remove map from HySetupAndEvolution.input
  our $bal;  $bal = qr/\((?:(?>[^()]+)|(??{$bal}))*\)/;
  $text =~ s/SpatialCoordMapItems\s*${bal}\s*[,]//sg;

  # Replace CubicalBoundary
  {
    my @bounds = @{$params->{'HydroCubicalBoundary'}};
    foreach my $i (0..$#bounds) {
      $bounds[$i] /= 1.025;
    }
    my $repl = join(',',@bounds);
    $text    =~ s/(CubicalBoundary\s*=\s*)[^;]+;/$1$repl;/s;
  }

  # Edit HydroParams to add ExcisionMap stuff
  if($text =~ m/HydroParams\s*${bal}\s*,/s) {
    my $dum = $&;
    my $newentries="
      ExcisionCenter                     = 0,0,0;
      ExcisionRadiusName                 = ExcisionBoundaryRadiusSpectralGrid;
      FirstOrderRadiusOverExcisionRadius = 1.2;
      ExcisionMaskName                   = ExcisionMask;\n";
    my $newdum = $dum;
    $newdum    =~ s/^(HydroParams\s*\()/$1$newentries/s;
    $text      =~ s/\Q$dum\E/$newdum/;
  }

  Utils::OverwriteFile($dest, $text);
}

sub EditRingdownDoMultipleRuns {
  my($inputdir,$destdir,$params)=@_;
  local $_;

  my $src   = "$THISDIR/DoMultipleRuns.input";
  my $dest  = "$destdir/DoMultipleRuns.input";
  my $time  = $params->{'MatchTime'};
  my $InitL = $opt_L;
  my $MaxLAh = -1;
  my $Rmin  = $params->{'Rmin'}; 
  my $Rmid  = $params->{'Rmid'}; 
  my $Rmax  = $params->{'Rmax'}; 

  # Choose threshold to be the same as it is in inspiral
  my $thresh;
  my $threshbase=2.e-3; # May need to revisit if the remnant is high spin.
  if($opt_hydro)
  {
    $thresh=$threshbase/2.0;
  }
  else{
    my $xA = $params->{'CenterA'}; $xA =~ s/,.*//m;
    my $xB = $params->{'CenterB'}; $xB =~ s/,.*//m;
    # poor-man's mass ratio
    my $q  = abs($xA) < abs($xB) ? abs($xB/$xA) : abs($xA/$xB);
    $thresh=$threshbase/($q+1/$q);
  }
  
  my $cpdir    = $params->{'MatchCheckpointDir'};
  # If there is no premerger map, then 'MergerChunkSize' will be set at
  # some large value, since there was no map to set it.  In this case, we need
  # to choose a smaller initial damping size.  Not sure how to do it in this
  # case, so for now just pick a default value.
  my $InitTdamp= $opt_nopremergermap 
      ? 0.25 
      : $params->{'MergerChunkSize'} * 3.3333333; #Factor is Tdamp/Tstatechange
  if($InitTdamp<0.03) {$InitTdamp=0.03;}

  # NSNS mergers do not have short timescale control systems before ringdown;
  # using the pre-ringdown timescale leads to poor ringdown shape control.
  # For now, guess at the correct timescale...
  if($opt_hydro)
  {
      $InitTdamp = 0.1;
  }

  if($opt_nopremergermap && !(-f $src)) {
    warn "Warning: No DoMultipleRuns.input file found\n";
    return 1;
  }

  if(defined $opt_ncyl && $opt_ncyl>0) {
    # We want MaxLAh to be allowed to grow, but not too much.
    # We set InitL+10 arbitrarily, probably need to revisit.
    # Another idea is to just cap MaxLAh at some large value like 100.
    #
    # If you don't set this, then for sufficiently high mass ratio
    # (i.e. sufficiently fine cylinders) the Ah finds during
    # InitialAMR will not meet their convergence criteria and will
    # then increase L until they run out of memory.
    $MaxLAh = $InitL+10;
  }
  
  my $text;
  my $FoundIdDir      = undef;
  my $FoundIdDirData  = undef;
  my $FoundIdDirCpDir = undef;
  my $FoundInitL      = undef;
  my $FoundMaxLAh     = undef;
  my $FoundRmax       = undef;
  my $FoundStartTime  = undef;
  my $FoundTdamping   = undef;
  my $FoundGrProcs    = undef;
  my $FoundProcs      = undef;
  my $FoundThresh     = undef;
  my @text = Utils::ReadFile($src);
  foreach (@text) {
    if(s/^([^#]*\$StartTime\s*=\s*")([^"]+)";/$1$time";/) {
      $FoundStartTime=1;
    }
    if(s/^([^#]*\$IdDir\s*=\s*")([^"]+)";/$1$destdir";/) {
      $FoundIdDir=1;
    }
    if(s/^([^#]*\$Threshold\s*=\s*")([^"]+)";/$1$thresh";/) {
      $FoundThresh=1;
    }
    if(s/^([^#]*\$IdDirData\s*=\s*")([^"]+)";/$1$inputdir";/) {
      $FoundIdDirData=1;
    }
    if(s/^([^#]*\$IdDirCpDir\s*=\s*")([^"]+)";/$1$cpdir";/) {
      $FoundIdDirCpDir=1;
    }
    if(s/^([^#]*\$InitLAh\s*=\s*")([^"]+)";/$1$InitL";/) {
      $FoundInitL=1;
    }
    if(s/^([^#]*\$MaxLAh\s*=\s*")([^"]+)";/$1$MaxLAh";/) {
      $FoundMaxLAh=1;
    }
    if(s/^([^#]*\$Rmax\s*=\s*")([^"]+)";/$1$Rmax";/) {
      $FoundRmax=1;
    }
    if(s/^([^#]*\$Tdamping\s*=\s*")([^"]+)";/$1$InitTdamp";/) {
      $FoundTdamping=1;
    }
    if($opt_hydro) {
      if(s/^([^#]*\$NumGrProcs\s*=\s*")([^"]+)";/$1$opt_ngrprocs";/) {
        $FoundGrProcs=1;
      }
      if(s/^([^#]*\$Processors\s*=\s*")([^"]+)";/$1$opt_ntotalprocs";/) {
        $FoundProcs=1;
      }
    }
    $text .= $_;
  }

  die "Cannot find 'IdDir'      in $src" unless ($FoundIdDir);
  die "Cannot find 'IdDirData'  in $src" unless ($FoundIdDirData);
  die "Cannot find 'IdDirCpDir' in $src" unless ($FoundIdDirCpDir);
  die "Cannot find 'StartTime'  in $src" unless ($FoundStartTime);
  die "Cannot find 'InitLAh'    in $src" unless ($FoundInitL);
  die "Cannot find 'MaxLAh'     in $src" unless ($FoundMaxLAh);
  die "Cannot find 'Threshold'  in $src" unless ($FoundThresh);
  if(not $FoundRmax) {
      print "WARNING:  Did not find Rmax in DoMultipleRuns.input.\n";
      print "WARNING:  Assume this is due to old inspiral files.\n";
  }
#  die "Cannot find 'Rmax'       in $src" unless ($FoundRmax);
  die "Cannot find 'Tdamping'   in $src" unless ($FoundTdamping);
  if($opt_hydro) {
    die "Cannot find 'NumGrProcs' in $src" unless ($FoundGrProcs);
    die "Cannot find 'Processors' in $src" unless ($FoundProcs);
  }

  Utils::OverwriteFile($dest, $text);
}

#---------------
sub MakeDomainInputFile {
  my($destdir,$params, $output_filename)=@_;
  local $_;

  unless (defined $output_filename) {
    $output_filename = "GrDomain.input";
  }
  
  my $DomainInput;

  my $Rmax = $params->{'Rmax'}; 
  my $Rmid = $params->{'Rmid'};
  my $Rmin = $params->{'Rmin'};

  if($opt_domaininput) {
    my $foundrmax=undef;
    my $foundrmin=undef;
    my $foundrmid=undef;

    my @text = Utils::ReadFile($opt_domaininput);
    foreach (@text) {
      $foundrmin=1 if(s/__Rmin__/$Rmin/g);
      $foundrmax=1 if(s/__Rmax__/$Rmax/g);
      $foundrmid=1 if(s/__Rmid__/$Rmid/g);
      $DomainInput .= $_;
    }

    die "$ME: Did not find '__Rmin__' in $opt_domaininput" unless($foundrmin);
    die "$ME: Did not find '__Rmax__' in $opt_domaininput" unless($foundrmin);
    die "$ME: Did not find '__Rmid__' in $opt_domaininput" unless($foundrmid);

  } else {
    # # Get bounds string.
    # my @bounds = @{$params->{'Bounds'}};
    # if(defined $opt_rmaxhack) {$bounds[$#bounds] -= $opt_rmaxhack;};
    # my $boundstring="";
    # {
    #   my $i=0;
    #   my $j=0;
    #   while($i<$#bounds) {
    #     $boundstring .= $bounds[$i] . ",";
    #     ++$i; ++$j;
    #     if($j>3) {
    #       $j=0;
    #       $boundstring .= "\n                                           ";
    #     }
    #   }
    #   $boundstring .= $bounds[$#bounds];
    # }

    my $sdsplit="";
    if($opt_njuggle>0) {
      $sdsplit = 
      "      ReplaceNInnerSpheresWithJuggleBalls=$opt_njuggle;
      JuggleBallSplitFactor              =2;";
    } elsif (defined $opt_ncyl && $opt_ncyl>0) {
      my $myThetaS;
      my $myThetaN;
      my $ThetaExtents;
      # initial AMR will adjust these
      my $NThetaCyl=20;
      my $NPhiCyl=30;

      my $xA = $params->{'CenterA'}; $xA =~ s/,.*//m; print "found xA = $xA\n";
      my $xB = $params->{'CenterB'}; $xB =~ s/,.*//m; print "found xB = $xB\n";
      # compute mass ratio
      my $q  = abs($xA) < abs($xB) ? abs($xB/$xA) : abs($xA/$xB);
      print "found approximate mass ratio = $q\n";
      
      if(abs($xA) < abs($xB)) {
        # Hole A is the large one, so we want the south pole
        # to have a smaller angle.  We choose the angle assuming large
        # mass ratio: the radius of the small hole is 2Ms, the distance
        # between the origin and the small hole is 2Ms+2Ml, so
        # tan(theta) = theta = 2Ms/(2Ms+2Ml) = 1/(1+q). We
        # use a fudge factor of 3 to make sure that the small hole
        # is contained in the new cylinder.
        # To account for the case of nearly equal masses, we don't let
        # the angle get larger than 20 degrees.
        $myThetaS = min(rad2deg(3.0/(1.0+$q)), 20);
        $myThetaN = 20; # Choose 20 degrees by default.
      } else {
        $myThetaN = min(rad2deg(3.0/(1.0+$q)), 20);
        $myThetaS = 20; # Choose 20 degrees by default.
      }
      print "will use ThetaS=$myThetaS, ThetaN=$myThetaN\n";
      
      $ThetaExtents = 
          "$NThetaCyl,$NThetaCyl,$NThetaCyl,$NThetaCyl,$NThetaCyl";
      if($q>4) { $ThetaExtents .=",$NThetaCyl"; }
      if($q>6) { $ThetaExtents .=",$NThetaCyl"; }
      if($q>8) { $ThetaExtents .=",$NThetaCyl"; }
      if($q>10) { $ThetaExtents .=",$NThetaCyl"; }
      print "will use ThetaExtents=".$ThetaExtents."\n";

      # We don't want the rotation angle to be larger than
      # the angle of the smallest cylinder.  It doesn't matter
      # what it is, as long as it is not exactly 90 degrees.
      # Use 0.1 times the estimated angle of the small hole.
      my $RotationAngle = max(89,90-rad2deg(0.1/(1.0+$q)));
      
      $sdsplit =
      "      ReplaceNInnerSpheresWithCylinders=$opt_ncyl;
      ReplaceCylinderPhiExtents=1+2*$NPhiCyl;
      ReplaceCylinderThetaExtents=$ThetaExtents;
      ReplaceCylinderEndcapAngleS=$myThetaS;
      ReplaceCylinderEndcapAngleN=$myThetaN;
      # Rotate onto the X axis.
      # We use $RotationAngle degrees instead of 90
      # to avoid pole on the axis
      # as there the invJacobian is singular.
      # This would mess up BoundaryInfo if it
      # works on point of a neighboring Subdomain
      # that does have a point on the axis.
      ReplaceCylinderEulerRotation=0,$RotationAngle,0;";
    }
    
    my $Lentry = "L        = __L__";
    if(defined($LAUTO)) {
      # I'm keeping commented __L__ around because DoMultipleRuns will
      # want to substitute it.
      my $DomainL = $opt_L + 4;
      $Lentry = "L        = $DomainL;   #__L__;";
    }

    $DomainInput =
"BoundaryInfo = (WarningLevel=0); # needed for split spheres
SubdomainStructure=
SphericalShells3D(
    BaseName = SphereD;
    $Lentry;
    r-Axis   = (Extents  = __Nr__;
                Maps     = $opt_mapr;
                IndexMap = ChebyshevGaussLobatto;
                Topology = I1;
                # upper bound must match SpatialCoordMaps.input
                Bounds = $Rmin, $Rmid;
                MaxScale=$opt_rwidfac;
                MaxWidth=$opt_rwidth;
               );
    $sdsplit
  ),
SphericalShells3D(
    BaseName = SphereE;
    $Lentry;
    r-Axis   = (Extents  = __Nr__;
                Maps     = $opt_mapr;
                IndexMap = ChebyshevGaussLobatto;
                Topology = I1;
                # lower bound must match SpatialCoordMaps.input
                Bounds = $Rmid, $Rmax;
                MaxScale=$opt_rwidfac;
                MaxWidth=$opt_rwidth;
               );
    # JuggleBall or Cylinder replacement only in SphereD
    );
FileBaseName = GrDomain;";
  }
  
  # Now write domain.input
  Utils::OverwriteFile("$destdir/$output_filename", $DomainInput."\n");
};

#---------------
# Forward-compose some (sub)set of maps
# Assumes complete order is Shape>>Rotation>>Scaling>>Translation
sub MapHolder {
  my (%Maps) = @_;

  my @MapOrder = ("Shape","Rotation","Scaling","Translation");

  # Sanity check
  {
    my @keys = keys(%Maps);
    my @UnknownMaps = Utils::Complement(\@keys, @MapOrder);
    die "Do not know maps: ".join(",",@UnknownMaps) if (@UnknownMaps);
  }

  my @DefinedMaps;  # ordered list of defined maps
  for my $map (@MapOrder) {
    push(@DefinedMaps, $map) if ($Maps{$map});
  }
  my $composition = join(">>",@DefinedMaps);

  return "ComposeSpatialCoordMapsFromHolder(
              HolderName = RingdownSpatialCoordMapHolder;
              SpatialDim = 3;
              Map = $composition;)";
}

#---------------
# Construct the AddSpatialCoordMapHolder item
sub ConstructHolderAdder {
  my (%Maps) = @_;

  my $string = "AddSpatialCoordMapHolder(\n".
    "Name = RingdownSpatialCoordMapHolder;\n".
    "SpatialCoordMaps =\n";
  for my $map (keys %Maps) {
    $string .= "$map(\n  Map = $Maps{$map}),\n" if ($Maps{$map});
  }
  $string .= ")";
  return $string;
}

#---------------
sub MakeSpatialCoordMapInputFile {
  my($destdir,$params,$output_filename)=@_;

  unless(defined $output_filename) {
    $output_filename = "SpatialCoordMap.input";
  }

  # Construct strings
  my %KinematicMaps = KinematicalMaps($params);
  my %DistortionMaps = DistortionMaps($params);
  my %AllMaps = (%KinematicMaps, %DistortionMaps);

  my $DistortedToInertialHolder = MapHolder(%KinematicMaps);
  my $GridToDistortedHolder = MapHolder(%DistortionMaps);
  my $GridToInertialHolder = MapHolder(%AllMaps);
  my $HolderAdder = ConstructHolderAdder(%AllMaps);

  my $fnvstimeKinematic = IntermediateKinematicalMapFnVsTimeString(
    $params,"__DIROLD__/","__DIROLD__/","__DIR__/",undef);
  my $fnvstimeDistortion = DistortionFnVsTimeString("__DIR__",$params);

  # Add non-empty strings to a list
  my @DomainItems;

  push(@DomainItems,$HolderAdder) if ($HolderAdder);
  push(@DomainItems,$fnvstimeKinematic) if ($fnvstimeKinematic);
  push(@DomainItems,$fnvstimeDistortion) if ($fnvstimeDistortion);
  if($opt_hydro) {
    push(@DomainItems,"
           SpatialCoordMapItems
           (Prefix         = InverseMapBetweenDomains;
            InputCoords    = <<Grid>>;
            MapIsVolatile  = true;
            Map            = CoordToSpatialCoordMap(CoordMap=Identity(Dim=3););
           )");
  }
  push(@DomainItems,"
           SpatialCoordMapItems
           (Prefix      = GridTo${opt_inertial};
            InputCoords = <<Grid>>;
            Map = $GridToInertialHolder;
           )");
  push(@DomainItems,"
           SpatialCoordMapItems
           (Prefix      = DistortedTo${opt_inertial};
            InputCoords = GridToDistorted::MappedCoords;
            Map = $DistortedToInertialHolder;
           )");
  push(@DomainItems,"
           SpatialCoordMapItems
           (Prefix      = GridToDistorted;
            InputCoords = <<Grid>>;
            Map = $GridToDistortedHolder;
           )");

  # Construct the full string and write to file
  my $SpatialCoordMap =
"DataBoxItems=
    Domain(Items = " . join(",",@DomainItems) . "
    );\n";

  Utils::OverwriteFile("$destdir/$output_filename",$SpatialCoordMap);
}

#---------------

sub MakePreRingdownHySpatialCoordMapInputFile {
  my($destdir,$params)=@_;

  my $SpatialCoordMapInput = "
DataBoxItems=
    ReadFromFile(File=$opt_inputdir/ControlParams.input),
    Domain
    (Items=
     SpatialCoordMapItems
     (Prefix         = MapBetweenDomains;
      InputCoords    = <<Grid>>;
      Map            = CoordToSpatialCoordMap(CoordMap=Identity(Dim=3););
      MapIsVolatile  = true;
      ),
     SpatialCoordMapItems
     (Prefix        = GridToInertialFD;
      InputCoords   = <<Grid>>;
      Map           = 
          ReadFromFile(FileName=$opt_inputdir/RotationTranslationMap.input);
      MapIsVolatile = true;
      );
     );";

  # Now write file
  Utils::OverwriteFile("$destdir/PreRingdownHySpatialCoordMap.input", 
                       $SpatialCoordMapInput."\n");
}


#---------------
sub MakeHyInitialFunctionVsTimesInput {
  my($inputdir,$destdir,$params)=@_;

  my $fnvstimekinematic=IntermediateKinematicalMapFnVsTimeString
      ($params,"$inputdir/","$inputdir/","$destdir/",undef);
  my $fnvstimedistortion=DistortionFnVsTimeString($destdir,$params);
  
  if(length($fnvstimekinematic)>0)  {$fnvstimekinematic  .= ",";}
  if(length($fnvstimedistortion)>0) {$fnvstimedistortion .= ",";}

  my $SpatialCoordMapInput =
" # These FunctionVsTimes should be included in the initial data setup
 # for the Hydro grid.  During the evolution, they are linked from the
 # GR grid to the Hydro grid, so they don't need to be included explicitly.
 DataBoxItems=
    Domain(Items =
           $fnvstimedistortion
           $fnvstimekinematic
          );";

  # Now write file
  Utils::OverwriteFile("$destdir/HyInitialFunctionVsTimes.input", 
                       $SpatialCoordMapInput."\n");
}

#---------------
sub MakeHySpatialCoordMapInputFile {
  my($inputdir,$destdir,$params)=@_;

  my %kinematic  = KinematicalMaps($params);
  my %distortion = DistortionMaps($params);

  my %AllMaps = (%kinematic,%distortion);
  my $GridToInertialHolder = MapHolder(%AllMaps);
  my $HolderAdder = ConstructHolderAdder(%AllMaps);

  my $SpatialCoordMapInput = 

"DataBoxItems=
    Domain(Items =
           SpatialCoordMapItems
           (Prefix         = MapBetweenDomains;
            InputCoords    = <<Grid>>;
            MapIsVolatile  = true;
            Map            = CoordToSpatialCoordMap(CoordMap=Identity(Dim=3););
           ),
           SpatialCoordMapItems
           (Prefix         = GridToInertialFD;
            InputCoords    = <<Grid>>;
            MapIsVolatile  = true;
            Map = $GridToInertialHolder;
           ),
           $HolderAdder,
          );";

  # Now write file
  Utils::OverwriteFile("$destdir/HySpatialCoordMap.input", 
                       $SpatialCoordMapInput."\n");
}

#---------------
sub MakeCombinedStateChangersInputFile {
  my($destdir,$params)=@_;

  my $matchtime = $params->{'MatchTime'};

  my($dist,$disttag)   = DistortionStateChangerString($params);
  $dist    .= "," unless($dist eq ""); 
  $disttag .= "," unless($dist eq ""); 

  my $chunktime   ="";
  my $chunktimetag="";
  if($opt_autotdamp) {
    $chunktime    = "ControlChunks(EventTriggerForApply=EveryChunk;),";
    $chunktimetag = "
      ControlChunks(
        StateChanger = 
          AdjustSubChunksToDampingTimes
           (IgnoreTheseKeys     = LambdaFactor0;
            MaxChunkSize        = 0.2; # allows AMR to keep up with merger GW
            IgnoreTheseMultiVarsComponents = Char,Scri;
            AssumeSingleMultiVarsComponent = no;);
      ),";
    if($dist ne "") {
      $chunktime .= "
       ControlTimeStep(EventTriggerForApply=AhSpeedApplyPlusInitialStep;),";
      $chunktimetag .= "
      ControlTimeStep(
        StateChanger = 
          AdjustMaxTstepToDampingTimes
           (IncludeOnlyTheseKeys = LambdaFactor0;
            IgnoreTheseMultiVarsComponents = Char,Scri;
            AssumeSingleMultiVarsComponent = no;
            TstepOverTdamp       = 0.1; # So Tchange/Tdamp < 0.3
           );
      ),";
    }
  }

  my $StateChangersInput =
      "StateChangers = 
       $chunktime";

  # remove any trailing commas and add semicolon at end
  $StateChangersInput =~ s/[,\s]*$/;/;

  $StateChangersInput .= "
StateChangerEventTriggers = 
    EveryChunk(Trigger=
               EveryNChunks(NChunks        = 1;
                            NoTriggerOnZero=yes) &&
                            !TriggerValueNearTarget(Target=$matchtime;
                                                    Delta =__NoChangeDt__)),
    AhSpeedApplyPlusInitialStep(Trigger = 
                                EveryNSteps(NSteps           = 3;
                                            NoTriggerOnZero  = no));\n";
  $StateChangersInput .= "
      StateChangerTags =
       $chunktimetag";

  # remove any trailing commas and add semicolon at end
  $StateChangersInput =~ s/[,\s]*$/;/;

  # Now write file
  Utils::OverwriteFile("$destdir/CombinedStateChangers.input", 
                       $StateChangersInput."\n");
}

#---------------
sub MakeStateChangersInputFile {
  my($destdir,$params)=@_;

  my $matchtime = $params->{'MatchTime'};

  my($trans,$transtag) = TranslationStateChangerString($params);
  $trans    .= "," unless($trans eq ""); 
  $transtag .= "," unless($trans eq ""); 
  my($dist,$disttag)   = DistortionStateChangerString($params);
  $dist    .= "," unless($dist eq ""); 
  $disttag .= "," unless($dist eq ""); 
  my $chunktime = "";
  my $chunktimetag="";
  if($opt_hydro)
  {
    $chunktime    = "ControlChunks(EventTriggerForApply=EveryChunk;),";
    $chunktimetag = "
      ControlChunks(
        StateChanger = 
          AdjustSubChunksToDampingTimes
           (IgnoreTheseKeys     = LambdaFactor0;
            MaxChunkSize        = 0.2; # allows AMR to keep up with merger GW
            );
      ),";
    if($dist ne "") {
      $chunktime .= "
       ControlTimeStep(EventTriggerForApply=AhSpeedApplyPlusInitialStep;),";
      $chunktimetag .= "
      ControlTimeStep(
        StateChanger = 
          AdjustMaxTstepToDampingTimes
           (IncludeOnlyTheseKeys = LambdaFactor0;
            TstepOverTdamp       = 0.1; # So Tchange/Tdamp < 0.3
           );
      ),";
    }      
  }

  # Check whether the ringdown input files use the filter adder.
  # this is here as a transitional step--so that people's runs
  # currently underway don't die when they start auto-ringdowns.

  my $addghfilteritems = "";
  my $filetocheck = "$THISDIR/DataBoxItems.input";
  unless(-f $filetocheck) {
    $filetocheck = "$THISDIR/GrDataBoxItems.input";
  }
  if(-f $filetocheck) {
    my $text = Utils::ReadFile($filetocheck);
    unless($text =~ m/AddGhFilterItems/) {
      my $deps = "";
      {
        my(@deps);
        push(@deps,"Translation")  if($trans ne "");
        push(@deps,"Size","Shape") if($dist  ne "");
        if(scalar(@deps)>0) {
          $deps = "StateChangerDependsOn=" . join(',',@deps) . ";";
        }
      }
      $addghfilteritems = "
EventAndItemAdders = 
    AddGhFilterItems(SpectralTransformer=Standard;
                     TransformToStandardBasis = no;
                     $deps
                     MapPrefixGridToInputFrame= GridTo${opt_inertial};);\n";
    }
  } elsif($opt_nopremergermap) {
    warn "Warning: No filtering StateChanger added to StateChangers.input\n";
  } else {
    die "Cannot find $filetocheck";
  }

  if($opt_autotdamp) {
    my $deps = "";
    {
      my(@deps);
      push(@deps,"Translation")  if($trans ne "");
      push(@deps,"Shape")        if($dist  ne "");
      if(scalar(@deps)>0) {
        $deps = "ApplyDependsOn=" . join(',',@deps) . ";";
      }
    }
  }

  my $StateChangersInput =
      "StateChangers = 
       $trans
       $dist
       $chunktime";

  # remove any trailing commas and add semicolon at end
  $StateChangersInput =~ s/[,\s]*$/;/;

  $StateChangersInput .= "
StateChangerEventTriggers = 
    EveryChunk(Trigger=
               EveryNChunks(NChunks        = 1;
                            NoTriggerOnZero=yes) &&
                            !TriggerValueNearTarget(Target=$matchtime;
                                                    Delta =__NoChangeDt__)),
    AhSpeedApply(Trigger = 
                 EveryNSteps(NSteps           = 3;
                             NoTriggerOnZero  = yes)),
    AhSpeedApplyPlusInitialStep(Trigger = 
                                EveryNSteps(NSteps           = 3;
                                            NoTriggerOnZero  = no));
StateChangerDenseTriggers = 
    AhSpeedMeasure(Trigger = EveryNSteps(NSteps=1;NoTriggerOnZero=no;)),";

  if($opt_autotdamp) {
    $StateChangersInput .= "
    PerChunkMeasure(Trigger = 
                      StepAfterChunkFraction(Frac = __MeasureFractionOfChunk__;
                                             TstartIsStartOfChunk =yes;
                                             NoTriggerNearChunkEps=0.05;));\n";
  } else {
    $StateChangersInput .= "
    EveryDeltaTMControl(Trigger=
                        EveryDeltaT(DeltaT =__DeltaTMControl__;
                        NoTriggerOnZero=no));\n";
  }

  $StateChangersInput .= "
      StateChangerTags =
       $transtag
       $disttag
       $chunktimetag";

  # remove any trailing commas and add semicolon at end
  $StateChangersInput =~ s/[,\s]*$/;/;

  $StateChangersInput .= $addghfilteritems;

  # Now write file
  Utils::OverwriteFile("$destdir/GrStateChangers.input", 
                       $StateChangersInput."\n");
}

#-------------------------------------------------------------------
#-------------------------------------------------------------------
# Routines that *write* StateChanger files.
#-------------------------------------------------------------------
#-------------------------------------------------------------------

# Returns ($statechanger,$statechangertag)
#
sub DistortionStateChangerString {
  my($params)=@_;
  
  my $matchtime = $params->{'MatchTime'};
  my $Rah       = $params->{'RAh'};  
  my $thresh = "__Threshold__";
  
  my $controllername= "ControlNthDeriv";
  my $dampstring    = "TimescaleTuner = Formula(Timescale =__Tdamping__);";
  my $dampstring0   = "TimescaleTuner = Formula(Timescale =__Tdamp00__);";
  my $controlstring;
  if($opt_tsbounded) {
    $controlstring = 
          "TimescaleTuner      = Bounded(Threshold          = $thresh;
                                         MinDampTime        = 0.1*__Tdamping__;
                                         MaxDampTime        = 20;
                                         ZeroCrossingPredictor = 
                                         (CheckpointFile = Cp-ZeroXTdamplm.txt;
                                          StencilSize    = 4);";
  } else {
    $controlstring = "TimescaleTuner      = Simple(MaxThreshold = $thresh;";
  }
  my $controlstring0= "TimescaleTuner      = Simple(MaxThreshold = 0.001;";
  my $extraopts;
  if($opt_pid && $opt_derivorderfvt == 2) {
    $extraopts = "
            Controller     = Pid(AdjustForTimeOffset = true;);";
  } else {
    $extraopts = "
            Controller     = PNd(AdjustForTimeOffset = true;);";
  }
  # Even if $opt_pid is set, use PNd for AhSpeed control.
  #
  # The reason is that PID does not always react quickly when
  # the timescale needs to be substantially reduced (This sometimes happens 
  # in AhSpeed control when the system is in State X and it needs to stay 
  # in State X but at a shorter timescale because the thing that State X is
  # controlling is threatening to cross zero).
  # The reason that PID cannot always respond is that the integral term
  # in PID can be arbitrarily large and of either sign (due to past history) 
  # at the time a quick change in timescale is needed.  If this term is of
  # the wrong sign (e.g. Q is < 0 and decreasing rapidly but the integral 
  # term is > 0), then decreasing the timescale just makes the integral term
  # larger (the coefficient goes like 1/tdamping^3), and the integral term
  # dominates and prevents Q from going to zero.  This happened in a series
  # of BBH ringdowns in October 2012.
  #
  # One solution to this problem would be for the MeasureControl* to always
  # claim "DiscontinuousChangeHasOccurred", which resets the integral term,
  # but also resets all the averagers and causes a delay before the control
  # system will act.  We don't want this delay, since the whole point is to
  # rapidly adjust the map to prevent an imminent disaster.
  #
  # Another solution would be for the MeasureControl* to call some new function
  # in the controller class that resets the integral term.  This would be
  # non-generic code (i.e. there would be PID specific code in classes that
  # have arbitrary controllers, or there would be new member functions that do
  # nothing for PNd).
  #
  # Yet another solution would be to give MeasureControl* the ability to switch
  # between PID (in smooth regions) and PND (where rapid change is needed).
  #
  # For now, the easiest solution is to just use PND.
  my $extraopts0 = "
         Controller     = PNd(AdjustForTimeOffset = true;
                              DerivOrderQ         = 2);";
  my $avgeropts ="UseAverageQ    = true;
                             Taverage       = Fraction(Value=0.25);";
  my $avgeropts0="UseAverageQ    = true;
                          Taverage       = Fraction(Value=0.25);";

  my $trigger;
  my $tscontrol;
  my $tscontrol0;

  if($opt_autotdamp) {
    $trigger   = "PerChunkMeasure";
    $tscontrol = "$controlstring
                                        MaxThresholdItem   =DeltaR0AhCOver20;
                                        DtMaxThresholdItem =DtDeltaR0AhCOver20;
                                        CrossingTimeFac= 0.5;
                                        IncreaseFactor = 1.01;
                                        DecreaseFactor = 0.98;
                                        InitialState   = Specified
                                        (Tdamping=__Tdamping__);
                                        CheckpointFile = 
                                        Cp-TdampLambdaFactorlm.txt;);";
    $tscontrol0 = "$controlstring0
                                        IncreaseFactor = 1.01;
                                        DecreaseFactor = 1.0;
                                        MinDampTime    = __MinTStep__;
                                        MaxDampTime    = 20;
                                        InitialState   = Specified
                                        (Tdamping=__Tdamp00__);
                                        CheckpointFile = 
                                        Cp-TdampLambdaFactor0.txt;);";
  } else {
    $trigger    = "EveryDeltaTMControl";
    $tscontrol  = $dampstring;
    $tscontrol0 = $dampstring0;
  }

  my $trigger0    = "AhSpeedMeasure";
  my $sctrigger0  = "AhSpeedApply";
  $extraopts0 .="
         AllowResetAverager   = true;
         AllowAdjustSubChunks = yes; #Not really;see MaxTimestepControl below.";

  my $MeasureControlParam =
        "AhSpeed
         (FunctionVsTime             = LambdaFactor0;
          FunctionVsTimeRAh          = SmoothRAhC;
          FunctionVsTimeMinDeltaRNoLam00 = SmoothMinDeltaRNoLam00AhC;
          InitialState               = 2;
          Priority                   = TrackAh;
          DeltaRPolicy               = Relative;
          ExcisionDriftVelocity      = 0.005;
          State5TimeScale            = 2;
          SuggestedTimeScaleFac      = 0.75;
          CharSpeedLimitForState3    = 0.08;
          DeltaRLimitForState3       = 0.08;
          State2Threshold            = 1e-3;
          State2DecreaseFactor       = 0.99;
          FramePrefixOfInertialFrame = $opt_inertial;
          MapPrefixAhToInertial      = DistortedTo$opt_inertial;
          CheckpointFile             = Cp-AhSpeedC.txt;
          DiagnosticsFile            = DiagAhSpeedC.dat;
          ExcisionBdryCenter         = 0.0,0.0,0.0;
          SuggestTimeScaleToCaller   = true;
          Verbose                    = 1;
          ZeroCrossingPredictor      = 
          (CheckpointFile = Cp-ZeroXAhSpeedC.txt;
           StencilSize    = 4;
          );
         );";

  my $decoupled = ($opt_decoupled ? "DecoupledShapeMap = true;" : "");
  my $ShapeControl = "ShapeAh
           (SurfaceInfo       = AhC;
            SurfaceId         = ;
            FunctionVsTime    = LambdaFactor;
            FunctionVsTime0   = LambdaFactor0;
            CoefThreshold     = 1.e-4;
            $decoupled
            Center            =0,0,0;
            CheckpointFile    = Cp-ControlShapeAhC.txt;
            )";

  my $statechanger = "
   Shape(EventTriggerForApply=EveryChunk;DenseTriggerForUpdate=$trigger;
         UpdateDependsOn=AhC),
   Size(EventTriggerForApply=$sctrigger0;DenseTriggerForUpdate=$trigger0;)";

  my $statechangertags = "
   Shape(
     StateChanger=
           $controllername
           (FunctionVsTime     =LambdaFactor;
            MeasureControlParam=
            $ShapeControl;
            $tscontrol$extraopts
            Averager=Exp(CheckpointFile = Cp-LambdaFactorlm.txt;
                         $avgeropts
                        );
           );
         ),
   Size(
     StateChanger=
        $controllername
        (FunctionVsTime      = LambdaFactor0;
         MeasureControlParam =
         $MeasureControlParam
         $tscontrol0$extraopts0
         Averager=Exp(CheckpointFile = Cp-LambdaFactor0.txt;
                      $avgeropts0
                     );
         );
        )";                      
  return($statechanger,$statechangertags);
}

#---------------
#
# Returns ($statechanger,$statechangertag)
#
sub TranslationStateChangerString {
  my($params)=@_;
  
  my $matchtime     = $params->{'MatchTime'};
  my $trans         = $params->{'UseTranslationMap'};
  my $userotation   = $params->{'UseRotationMap'};

  return("","") unless($trans);
  die "Confusing string '",$trans,"'" unless ($trans =~ m/^[01]{3}$/);

  my $thresh = "__Threshold__";
  
  # Get MeasureControlParam string
  my $measurecontrolparam;
  {
    # get transstring to determine which axes to disable.
    my $transstring=$trans;
    $transstring =~ s/1/false/g; # 1 is false cuz the flag is 'DisableAxis'
    $transstring =~ s/0/true/g;  # 0 is true  cuz the flag is 'DisableAxis'
    $transstring =~ s/e(.)/e,$1/g; # Sneaky way to put commas in.

    if($userotation eq 'NoHistory') {
      $userotation = $params->{'RotationMapFvTType'};
    }
    
    if($userotation eq 'PitchAndYaw') {
      $measurecontrolparam = 
          "               Translate3D
                          (SurfaceInfo     = AhC;
                           SurfaceId       = ;
                           #DisableAxis     = ${transstring};
                           PitchAndYaw     = PitchAndYawSettle;
                           ExpansionFactor =;
                          )";
    } elsif($userotation eq 'QuaternionRotInv') {
      $measurecontrolparam =
          "             Translate3dQuat
                        (SurfaceInfo     = AhC;
                         SurfaceId       = ;
                         #DisableAxis    = ${transstring};
                         QuatRotMatrix   = QuatRotMatrixSettle;
                         ExpansionFactor =;
                        )";
    } elsif($userotation eq 'QuaternionFvT') {
      $measurecontrolparam =
          "             Translate3dQuat
                        (SurfaceInfo     = AhC;
                         SurfaceId       = ;
                         #DisableAxis    = ${transstring};
                         QuatRotMatrix   = QuaternionSettle;
                         ExpansionFactor =;
                        )";
    } elsif($userotation eq 'None') {
      $measurecontrolparam = 
          "               Translate3D
                          (SurfaceInfo     = AhC;
                           SurfaceId       = ;
                           #DisableAxis     = ${transstring};
                           PitchAndYaw     =;
                           ExpansionFactor =;
                          )";
    } else {
      die "Do not understand userotation = '",$userotation,"'";
    }
  }

  my $controllername= "ControlNthDeriv";
  my $dampstring    = "TimescaleTuner      = Formula(Timescale = __TdampT__;);";
  my $controlstring;
  if($opt_tsbounded) {
    $controlstring = 
          "TimescaleTuner      = Bounded(Threshold         = $thresh;
                                         MinDampTime       = 0.1*__TdampT__;
                                         MaxDampTime       = 20;
                                         ZeroCrossingPredictor = 
                                         (CheckpointFile = Cp-ZeroXTdampT.txt;
                                          StencilSize    = 4);";
  } else {
    $controlstring = "TimescaleTuner      = Simple(MaxThreshold = $thresh;";
  }
  my $extraopts;
  if($opt_pid && $opt_derivorderfvt == 2) {
    $extraopts = "
                Controller     = Pid(AdjustForTimeOffset = true;);";
  } else {
    $extraopts = "
                Controller     = PNd(AdjustForTimeOffset = true;);";
  }
  my $avgeropts ="UseAverageQ    = true;
                             Taverage       = Fraction(Value=0.25);";

  my $trigger;
  my $tscontrol;

  if($opt_autotdamp) {
    $trigger   = "PerChunkMeasure";
    $tscontrol = "$controlstring
                                        MaxThresholdItem   =DeltaR0AhCOver20;
                                        DtMaxThresholdItem =DtDeltaR0AhCOver20;
                                        CrossingTimeFac= 0.5;
                                        IncreaseFactor = 1.01;
                                        DecreaseFactor = 0.98;
                                        InitialState   = Specified
                                        (Tdamping=__TdampT__);
                                        CheckpointFile = 
                                        Cp-TdampTransSingleHole.txt;);";
  } else {
    $trigger    = "EveryDeltaTMControl";
    $tscontrol  = $dampstring;
  }

  my $statechanger    = "
   Translation(EventTriggerForApply =EveryChunk;
               DenseTriggerForUpdate=$trigger;
               UpdateDependsOn = AhC)";
  my $statechangertag = "
   Translation(
     StateChanger=
           $controllername
           (FunctionVsTime     = TransSingleHole;
            MeasureControlParam= $measurecontrolparam;
            $tscontrol$extraopts
            Averager=Exp(CheckpointFile = Cp-TransSingleHole.txt;
                         $avgeropts
                        );
            );
           )";
  return($statechanger,$statechangertag);
}

#-------------------------------------------------------------------
#-------------------------------------------------------------------
# Routines that *write* map files.
#-------------------------------------------------------------------
#-------------------------------------------------------------------

# Outputs string defining the full intermediate kinematical map FnVsTime.
sub IntermediateKinematicalMapFnVsTimeString {
  my($params,$histdirlastsegment,$histdirlocal,
     $initdir,$translationusehistory)=@_;

  my $rot   = RotationFnVsTimeString($params,$histdirlastsegment);
  my $trans = TranslationFnVsTimeString($params,$histdirlocal,
                                        $initdir,$translationusehistory);
  my $exp   = ExpansionFnVsTimeString($params,$histdirlastsegment);

  my $string="";
  if($exp   ne "") {$string .= "$exp"};
  if($rot   ne "") {$string .= ",\n$rot"};
  if($trans ne "") {$string .= ",\n$trans"};

  return $string;
}

#---------------
# Outputs hash with kinematical map strings
sub KinematicalMaps {
  my($params)=@_;

  # Initialize maps to the empty string
  my %maps;
  $maps{Rotation}    = "";
  $maps{Translation} = "";
  $maps{Scaling}     = "";

  # Determine which kinematic maps will be used
  my $translation = $params->{UseTranslationMap};
  my $useexpansion= $params->{UseExpansionMap};
  my $userotation = $params->{UseRotationMap};
  if($userotation eq "NoHistory") {
    $userotation = $params->{RotationMapFvTType};
  }

  # Set map parameters for all 3 maps
  my $Rmax0 = $params->{Rmax0};
  my $Rmax  = $params->{Rmax};
  my $R     = $params->{R};

  my $RotMatrix;
  if($userotation eq 'PitchAndYaw') {
    $RotMatrix = "PitchAndYaw(PitchAndYawAngles=PitchAndYawSettle)";
  } elsif ($userotation eq 'QuaternionRotInv') {
    $RotMatrix = "QuatRotMatrixFromFunctionVsTime(
                  FunctionVsTime=QuatRotMatrixSettle)";
  } elsif ($userotation eq 'QuaternionFvT') {
    $RotMatrix = "QuatRotMatrixFromFunctionVsTime(
                  FunctionVsTime=QuaternionSettle;)";
  }

  my $TransMap;
  if($translation) {
    my $Tw = $params->{'Transwidth'};
    my $Tf = $params->{'Transfalloff'};
    my $RadialFunc = "GeneralizedGaussian(Center = 0.0;
                               Falloff= $Tf;
                               Width  = $Tw;
                               Power  = 2)";
    $TransMap = "SpatiallyDependentTranslation
        (TranslationFunction = TransSingleHole;
         Center              = 0.0,0.0,0.0;
         RadialFunction      = $RadialFunc;
        )";
  }

  # If using all 3 maps, use the preferred combined maps (see ticket #920).
  # For logistical reasons, put the combined map in Scaling, then return.
  if ($translation and ($useexpansion ne "None") and
      ($userotation eq "PitchAndYaw" || $userotation eq "QuaternionRotInv" 
                                     || $userotation eq "QuaternionFvT"))
  {
    $maps{Scaling} = "Compose(
          InitialMap = SmoothRotScaleBlend(
            R                = $R;
            Rmax             = $Rmax;
            Rmax0            = $Rmax0;
            ExpansionFactorA = ExpansionFactorSettle;
            ExpansionFactorB = ExpansionFactorA0Settle;
            RotationMatrix   = $RotMatrix;
          );
          FinalMap = $TransMap;
        )";
    return %maps;
  }

  # If not using all 3 maps, use the individual maps
  if ($useexpansion ne "None") {
    $maps{Scaling} = "BlendToMovingOuterBdry
                         (R                 = $R;
                          ExpansionFactorA0 = ExpansionFactorA0Settle;
                          Rmax0             = $Rmax0;
                          Rmax              = $Rmax;
                          ExpansionFactor   = ExpansionFactorSettle;)";
  }

  if(($userotation eq 'PitchAndYaw') or
     ($userotation eq 'QuaternionRotInv')  or
     ($userotation eq 'QuaternionFvT'))
  {
    $maps{Rotation} = "Rotation3d(RotationMatrix = $RotMatrix;)";
  } elsif ($userotation ne 'None') {
    die "Don't understand userotation = '",$userotation,"'";
  }

  if ($translation) {
    $maps{Translation} = $TransMap;
  }

  return %maps;
}

#---------------
# Outputs hash with distortion map strings
sub DistortionMaps {
  my($params)=@_;

  my %maps;
  my $startofmapstring = "MultiDistortedSphereAllYlm
       (LambdaFnVsTime[0]             = LambdaFactor0,LambdaFactor;";
  my $MinL             ="0";
  if($opt_decoupled) {
    $startofmapstring = "MultiDistortedSphereDecoupledYlm
       (LambdaFnVsTime0[0]            = LambdaFactor0;
        LambdaFnVsTime[0]             = LambdaFactor;";
    $MinL="1";
  }

  my $Rmin   = $params->{'Rmin'};
  my $Rmid   = $params->{'Rmid'};

  if($opt_hydro) {
    my $rmaxmap = 20*$Rmin;
    if($rmaxmap > $Rmid) {
      $rmaxmap = $Rmid;
    }

    $maps{"Shape"} = $startofmapstring . "
        InputFrameIsGridFrame         = yes;
        DistortedSphereMapFunction[0] = Smooth
         (Rexc                      = $Rmin;
          Center                    = 0.0,0.0,0.0;
          Rmax                      = $rmaxmap;
          Quiet                     = yes;
         );
       CutoffEpsForAdaptiveL = 1.e-13;
       ComponentLabels[0]    = YlmCoefs(MinL=$MinL;MaxL=$opt_L;
                                        ZSymmetric=no;
                                        OnlyEvenL=no;
                                        IncludeL1Mode=no;);
      )";
  } else {
    # # Figure out RmaxIndex.
    # my $RmaxIndex=0;
    # my @bounds = @{$params->{'Bounds'}};
    # while($RmaxIndex<$#bounds) {
    #   last if($Rmid == $bounds[$RmaxIndex]);
    #   ++$RmaxIndex;
    # }
    # die "Cannot find $RmaxIndex" if($RmaxIndex==$#bounds);

    my $IncludeTheseSubdomains = "SphereD*";
    if(defined $opt_ncyl && $opt_ncyl>0) {
      $IncludeTheseSubdomains .= ",*Cyl*";
    }
    $maps{"Shape"} = $startofmapstring . "
        InputFrameIsGridFrame         = yes;
        DistortedSphereMapFunction[0] = Sphere
         (Center                    = 0.0,0.0,0.0;
          Rmin                      = $Rmin;
          Rmax                      = $Rmid;   # yes, Rmid!  must match Domain.input
          IncludeTheseSubdomains    = $IncludeTheseSubdomains;
          ButExcludeTheseSubdomains = ;
         );
       CutoffEpsForAdaptiveL = 1.e-13;
       ComponentLabels[0]    = YlmCoefs(MinL=$MinL;MaxL=$opt_L;
                                        ZSymmetric=no;
                                        OnlyEvenL=no;
                                        IncludeL1Mode=no;);
      )";
  }
  return %maps;
}

#---------------
sub DistortionFnVsTimeString {
  my($initfilesdir,$params)=@_;

  my $matchtime = $params->{'MatchTime'};
  my $NumComps  = ($opt_L+1)*($opt_L+1)-4; # // All except l=1 and l=0

  return
        "          FunctionVsTime(Output         = LambdaFactor;
                          FunctionVsTime = NthTimeDeriv
                          (DerivOrder      = $opt_derivorderfvt;
                           ComponentLabels = YlmCoefs(MinL=1;MaxL=$opt_L;
                                                      ZSymmetric=no;
                                                      OnlyEvenL=no;
                                                      IncludeL1Mode=no;);
                           InitialData     = FromCheckpointFile
                                (File=$initfilesdir/Init-FuncLambdaFactor.txt;
                                 Time=$matchtime;
                                 Eps =1.e-6);
                           FileBaseName    = FuncLambdaFactor;
                          );
           ),
           FunctionVsTime(Output         = LambdaFactor0;
                          FunctionVsTime = NthTimeDeriv
                          (DerivOrder      = 3;
                           ComponentLabels = YlmCoefs(MinL=0;MaxL=0;
                                                      ZSymmetric=no;
                                                      OnlyEvenL=no;
                                                      IncludeL1Mode=no;);
                           InitialData     = FromCheckpointFile
                                (File=$initfilesdir/Init-FuncLambdaFactor0.txt;
                                 Time=$matchtime;
                                 Eps =1.e-6);
                           FileBaseName    = FuncLambdaFactor0;
                          );
           )";
}

#---------------
# The second argument is the directory to get Hist files from.
sub RotationFnVsTimeString {
  my($params,$dir)=@_;

  my $userotation  = $params->{'UseRotationMap'};
  my $matchtime    = $params->{'MatchTime'};
  my $ReadNthderiv = $params->{'RotationMapFnVsTimeNthDeriv'};

  if($userotation eq 'PitchAndYaw') {
    # InitialData below is bogus cuz of replay mode.
    my $FnVsTime = "
                     NthTimeDeriv(InitialData=Values(f=0.0;df=0.0;Tstart=0);
                                  DerivOrder=$ReadNthderiv;
                                  ComponentLabels=Specified(Labels=Pitch,Yaw);
                                  ForceReplayMode=yes;
                                  HistoryFile=${dir}Hist-FuncPitchAndYaw.txt;
                                  FileBaseName=FuncPitchAndYaw;)";
    return 
        "                    FunctionVsTime(Output         =PitchAndYawSettle;
                     FunctionVsTime=SettleToConstant
                     (MatchTime  = $matchtime;
                      DecayTime  = $opt_rotdecay;
                      InitialData= FromFnVsTime3rdDeriv(FnVsTime=$FnVsTime);
                      );
                    )";
  } elsif($userotation eq 'QuaternionRotInv') {
    # InitialData below is bogus cuz of replay mode.
    my $FnVsTime = "
                  NthTimeDerivRotInv(InitialData=Values(f=0.0;df=0.0;Tstart=0);
                                  DerivOrder=$ReadNthderiv;
                                  ComponentLabels=Specified
                                     (Labels=Quat1,Quat2,Quat3,Quat4);
                                  ForceReplayMode=yes;
                                  HistoryFile=${dir}Hist-FuncQuatRotMatrix.txt;
                                  FileBaseName=FuncQuatRotMatrix;)";
    die "Must use Nth deriv if using Quaternions" if (not $ReadNthderiv);
    return 
        "                    FunctionVsTime(Output     =QuatRotMatrixSettle;
                     FunctionVsTime=SettleToConstant
                     (MatchTime  = $matchtime;
                      DecayTime  = $opt_rotdecay;
                      InitialData= FromFnVsTimeRotInv(FnVsTime=$FnVsTime);
                      );
                    )";
  } elsif($userotation eq 'QuaternionFvT') {
    # InitialData below is bogus cuz of replay mode.
    my $OmegaFnVsTime = "
                 NthTimeDeriv(InitialData=Values(f=0.0;df=0.0;Tstart=0);
                                  DerivOrder=$ReadNthderiv;
                                  ComponentLabels=Specified
                                      (Labels=Omega1,Omega2,Omega3);
                                  ForceReplayMode=yes;
                                  HistoryFile=${dir}Hist-FuncOmega.txt;
                                  FileBaseName=FuncOmega;)";
    my $QuatFnVsTime = "
                  QuaternionFunctionVsTime(InitialData=Values(
                              Quaternion=1.0,0.0,0.0,0.0;Tstart=0);
                                  OmegaFvT = PostOmega;
                                  ComponentLabels=Specified
                                     (Labels=Quat1,Quat2,Quat3,Quat4);
                                  ForceReplayMode=yes;
                                  HistoryFile=${dir}Hist-FuncQuaternion.txt;
                                  FileBaseName=FuncQuaternion;)";
    die "Must use Nth deriv if using Quaternions" if (not $ReadNthderiv);
    return 
         "                   FunctionVsTime(Output     =QuaternionSettle;
                     FunctionVsTime=SettleToConstant
                     (MatchTime  = $matchtime;
                      DecayTime  = $opt_rotdecay;
                      InitialData= FromQuatFnVsTime(QuatFvT=$QuatFnVsTime;
                                                    OmegaFvT =$OmegaFnVsTime);
                      );
                    )";
  } elsif($userotation eq 'NoHistory') {
    my ($rotationtype, $FnVsTime);
    $FnVsTime = $params->{'RotationMapFvT'};
    $rotationtype = $params->{'RotationMapFvTType'}; 
    return 
        "                    FunctionVsTime(Output         =${rotationtype}Settle;
                     FunctionVsTime=SettleToConstant
                     (MatchTime  = $matchtime;
                      DecayTime  = $opt_rotdecay;
                      InitialData= FromFnVsTime3rdDeriv(FnVsTime=$FnVsTime);
                      # __DIROLD__ make DoMultipleRuns happy
                      );
                    )";
  } elsif($userotation eq "None") {
    return "";
  } else {
    die "Don't understand userotation='",$userotation,"'";
  }
}

#---------------
# The second argument is the directory to get Hist files from.
sub ExpansionFnVsTimeString {
  my($params,$dir)=@_;

  my $useexpansion      = $params->{'UseExpansionMap'};
  my $matchtime         = $params->{'MatchTime'};
  my $ReadNthderiv      = $params->{'ExpansionMapFnVsTimeNthDeriv'};
  my $ExpansionFactorFn = $params->{'ExpansionFactorA0FnVsTime'};

  if($useexpansion eq "None") {
    return "";
  }

  my $FnVsTime;
  if($useexpansion eq "NoHistory") {
    $FnVsTime = $params->{'ExpansionMapFvT'};
  } else {
    $FnVsTime = "
                  NthTimeDeriv(InitialData=Values(f=0.0;df=0.0;Tstart=0);
                               DerivOrder=$ReadNthderiv;
                               ComponentLabels=Specified(Labels=a);
                               ForceReplayMode=yes;
                               HistoryFile=${dir}Hist-FuncExpansionFactor.txt;
                               FileBaseName=FuncExpansionFactor;)";
  }

  my $output = 
     "FunctionVsTime(Output=ExpansionFactorSettle;
                     FunctionVsTime=SettleToConstant
                        (MatchTime  = $matchtime;
                         DecayTime  = $opt_expdecay;
                         InitialData= FromFnVsTime3rdDeriv(FnVsTime=$FnVsTime);
                     );
                   )";
  if(defined $ExpansionFactorFn) {
    $output .= ",
      FunctionVsTime(Output=ExpansionFactorA0Settle;
                     FunctionVsTime=SettleToConstant
                        (MatchTime   = $matchtime;
                         DecayTime   = $opt_expdecay;
                         InitialData = FromFnVsTime3rdDeriv
                            (FnVsTime=$ExpansionFactorFn);
                     );
                   )";
  }
  return $output;
}

#---------------
# The second argument is the directory to get Hist or init files from.
sub TranslationFnVsTimeString {
  my($params,$histdir,$initdir,$usehistory)=@_;

  my $translation = $params->{'UseTranslationMap'};
  my $txtytz      = $params->{'TransMapLabels'};

  if($translation) {
    if($usehistory) {
      my $TransHistFile = $params->{'TranslationHistoryFile'};
      my $derivorder=DerivOrderOfHistoryFile($TransHistFile);
      return      "
       FunctionVsTime(Output         = TransSingleHole;
                      FunctionVsTime = 
                      NthTimeDeriv(InitialData=Values(f=0.0;df=0.0;Tstart=0);
                                   DerivOrder=$derivorder;
                                   ComponentLabels=Specified(Labels=${txtytz});
                                   ForceReplayMode=yes;
                                   HistoryFile =${histdir}$TransHistFile;
                                   FileBaseName=FuncTransSingleHole;);
                     )";
    } else {
      my $matchtime    = $params->{'MatchTime'};
      return
            "      FunctionVsTime(Output         = TransSingleHole;
                   FunctionVsTime = 
                   NthTimeDeriv(DerivOrder     =$opt_derivorderfvt;
                                ComponentLabels=Specified(Labels=${txtytz});
                                InitialData    = FromCheckpointFile
                                (File=${initdir}Init-FuncTransSingleHole.txt;
                                 Time=$matchtime;
                                 Eps =1.e-6);
                                 FileBaseName  = FuncTransSingleHole;);
                     )";
    }
  } else {
    return "";
  }
}

#-------------------------------------------------------------------
#-------------------------------------------------------------------
# Routines that compute new grid parameters.
#-------------------------------------------------------------------
#-------------------------------------------------------------------

# compute the inner boundary of the grid, and the intermediate
# radius at which the distortion spheres are cut off.
sub ComputeRminRmid {
   my($params,$rminfac,$rmidfac)=@_;
   local $_;
   my $Rmax = $params->{'Rmax'};
   my $Rah  = $params->{'RAh'};
   my $Rmin = $rminfac * $Rah;
   my $Rmid = $rmidfac * $Rmin;
   $params->{'Rmin'}   = $Rmin;
   $params->{'Rmid'}   = $Rmid;
}

#-------------------------------------------------------------------
#-------------------------------------------------------------------
# Routines that get map parameters
#-------------------------------------------------------------------
#-------------------------------------------------------------------

# Sets $params->{'UseRotationMap'}
sub DoesPremergerHaveRotationMap {
  my($inputdir,$params)=@_;
  local $_;

  opendir(DIR,"$inputdir") || die "Cannot opendir $inputdir";
  my(@entry)=readdir(DIR);
  closedir(DIR);

  my $found=undef;
  unless($found) {
    foreach(@entry) {
      if(/^Hist-Func.*PitchAndYaw.*\.txt$/) {
        $params->{'UseRotationMap'}='PitchAndYaw';
        $found=1;
        last;
      }
    }
  }

  unless($found) {
    foreach(@entry) {
      if(/^Hist-Func.*QuatRotMatrix*\.txt$/) {
        $params->{'UseRotationMap'}='QuaternionRotInv';
        $found=1;
        last;
      }
    }
  }

  unless($found) {
    foreach(@entry) {
      if(/^Hist-Func.*Quaternion*\.txt$/) {
        $params->{'UseRotationMap'}='QuaternionFvT';
        $found=1;
        last;
      }
    }
  }

  if(!$found) {
    foreach(@entry) {
      # Read through all the input files
      if(/\.input$/) {
        my $text = Utils::ReadFile("$inputdir/$_");
        $text    =~ s/#.*$//mg; # Remove comments
        our $bal; $bal = qr/\((?:(?>[^()]+)|(??{$bal}))*\)/;
        while($text =~ m|FunctionVsTime\s*${bal}\s*[;,]|sg) {
          my $dum = $&;
          if($dum =~ m|Output\s*=\s*(PitchAndYaw)Angles\s*;|s) {
            my $rotationtype = $1;
            if($dum =~ m|FunctionVsTime\s*=\s*[^()]+${bal}\s*;|s) {
              my $inside = $&;
              $inside    =~ s|^FunctionVsTime\s*=\s*||s;
              $inside    =~ s|;$||;
              # Technically this should work with any map other than
              # SettleToConstant or FixedSpeed.  But we demand one of them here
              # just as a check, since this part of the code could be reached
              # if a history file is missing.
              if($inside =~ m/(SettleToConstant|FixedSpeed)/) {
                print "RotationMapFvT = $inside\n" if($opt_v);
                die "Found two Rotation maps, which to use?" if($found);
                $params->{'RotationMapFvT'}=$inside;
                $params->{'RotationMapFvTType'}=$rotationtype;
                $params->{'UseRotationMap'}='NoHistory';
                $found=1;
              }
            }
          }
        }
      }
    }
  }

  $params->{'UseRotationMap'}='None' if(!$found);

  print "Rotation map = ",$params->{'UseRotationMap'},"\n" if($opt_v);
}

# Sets $params->{'UseExpansionMap'}
sub DoesPremergerHaveExpansionMap {
  my($inputdir,$params)=@_;
  local $_;

  opendir(DIR,"$inputdir") || die "Cannot opendir $inputdir";
  my(@entry)=readdir(DIR);
  closedir(DIR);

  my $found=undef;
  foreach(@entry) {
    if(/^Hist-Func.*Expansion.*\.txt$/) {
      $params->{'UseExpansionMap'}='Expansion';
      $found=1;
      last;
    }
  }

  if(!$found) {
    foreach(@entry) {
      # Read through all the input files
      if(/\.input$/) {
        my $text = Utils::ReadFile("$inputdir/$_");
        $text    =~ s/#.*$//mg; # Remove comments
        our $bal; $bal = qr/\((?:(?>[^()]+)|(??{$bal}))*\)/;
        while($text =~ m|FunctionVsTime\s*${bal}\s*[;,]|sg) {
          my $dum = $&;
          if($dum =~ m|Output\s*=\s*ExpansionFactor\s*;|s) {
            if($dum =~ m|FunctionVsTime\s*=\s*[^()]+${bal}\s*;|s) {
              my $inside = $&;
              $inside    =~ s|^FunctionVsTime\s*=\s*||s;
              $inside    =~ s|;$||;
              # Technically this should work with any map other than
              # SettleToConstant.  But we demand SettleToConstant here
              # just as a check, since this part of the code could be
              # reached if a history file is missing.
              if($inside =~ m/SettleToConstant/) {
                print "ExpansionMapFvT = $inside\n" if($opt_v);
                die "Found two ExpansionFactor maps, which to use?" if($found);
                $params->{'ExpansionMapFvT'}=$inside;
                $params->{'UseExpansionMap'}='NoHistory';
                $found=1;
              }
            }
          }
        }
      }
    }
  }

  $params->{'UseExpansionMap'}='None' if(!$found);

  print "Expansion map = ",$params->{'UseExpansionMap'},"\n" if($opt_v);
}

#---------------
# Sets $params->{'UseTranslationMap'} to undef or to 
# xyz where each of x y z are 1 or 0 depending
# on if that translation is to be used.
# Also sets labels for translation map, $params->{'TransMapLabels'}
sub DoesPremergerHaveTranslationMap {
  my($inputdir,$params)=@_;
  local $_;

  opendir(DIR,"$inputdir") || die "Cannot opendir $inputdir";
  my(@entry)=readdir(DIR);
  closedir(DIR);

  $params->{'UseTranslationMap'}=undef;

  foreach(@entry) {
    if(/^Hist-Func.*Trans.*\.txt$/ && $_ ne "Hist-FuncTransX.txt") {
      # Now we have a translation map. Now read it and see
      # whether x, y, and z are nonzero.
      my $file = $_;
      my $DerivOrder = DerivOrderOfHistoryFile("$inputdir/$file");
      my @text = Utils::ReadFile("$inputdir/$file");
      foreach (@text) {
        next if(/^\s*#/); # skip comments
        # FunctionVsTimeNthDeriv format
        s/\s*//;    # Remove whitespace
        my @f;
        /T[^=]*[xX]/; my $tx = $&;
        /T[^=]*[yY]/; my $ty = $&;
        /T[^=]*[zZ]/; my $tz = $&;
        $params->{'TransMapLabels'} = "$tx,$ty,$tz";
        push(@f,
          /T[^=]*[xX]=([^;]+);/g,
          /T[^=]*[yY]=([^;]+);/g,
          /T[^=]*[zZ]=([^;]+);/g);
        my $FSize=$DerivOrder+1;
        if(scalar(@f)==$FSize*3) {
          my @array=();
          my @translationamount=();
          foreach my $i (0..2) {
            $array[$i]             = 0;
            $translationamount[$i] = $f[$FSize*$i];
            foreach my $k($FSize*$i..$FSize*$i+2) {
              if($f[$k] != 0.0) {
                $array[$i] = 1;
              }
            }
          }
          $params->{'UseTranslationMap'}=$array[0] . $array[1] . $array[2];
          $params->{'TranslationAmount'}=[@translationamount];
          $params->{'TranslationHistoryFile'}=$file;
        } else {
          die "Do not see the correct number of comps in $inputdir/$file :",
              " Fsize=$FSize, scalar f = ", scalar(@f);
        }
      }
      GetSpatiallyDependentTranslationWidth("$inputdir/SpatialCoordMap.input",
                                            $params);
      print "Trans map = ",$params->{'UseTranslationMap'},"\n"if($opt_v);
      print "Trans labels = ",$params->{'TransMapLabels'},"\n"if($opt_v);
      return;
    }
  }
}

#---------------
# Reads a SpatialCoordMap.input file containing a 
# 'SpatiallyDependentTranslation'
# Outputs 
# $params->{'Transwidth'} = $Width;
# $params->{'Transfalloff'} = $Falloff;
sub GetSpatiallyDependentTranslationWidth {
  my($file,$params)=@_;

  my $text = Utils::ReadFile($file);
  $text =~ s/#.*$//mg; # Remove comments ('m' means $ matches end of each line)
  $text =~ s/\n//g;    # Remove newlines
  $text =~ s/\s+//g;   # Remove whitespace

  # Check for the badly-designed "Map=ReadFromFile" construct
  {
    our $bal;  $bal = qr/\((?:(?>[^()]+)|(??{$bal}))*\)/;
    while($text =~ m/SpatialCoordMapItems${bal}[;,]/g) {
      my $dum = $&;
      if($dum =~ m/Map=ReadFromFile\(FileName=([^;\)]+)[;\)]/) {
        print "GetSpatiallyDependentTranslationWidth will read from file ",
        "$opt_inputdir/$1\n" if($opt_v);
        return GetSpatiallyDependentTranslationWidth("$opt_inputdir/$1",
                                                     $params); # Recursive call
      }
    }
  }

  my $Width     = undef;
  my $Falloff   = "1.0";

  if($text =~ m/SpatiallyDependentTranslation\([^()]*
     RadialFunction=GeneralizedGaussian\([^()]*Falloff=([.\d]+);/x) {
    $Falloff = $1;
  }
  
  if($text =~ m/SpatiallyDependentTranslation\([^()]*
                RadialFunction=GeneralizedGaussian\([^()]*Width=([.\d]+);/x) {
    $Width=$1;
  } elsif($text =~ m/SpatiallyDependentTranslation\([^()]*
          RadialFunction=GeneralizedGaussian\([^()]*Width=([.\d\*\+]+);/x) {
    # In case someone specifies the width as a formula
    $Width=eval $1;
  } else {
    ### $bal matches balanced parens with possible nested parens inside.
    our $bal;  $bal = qr/\((?:(?>[^()]+)|(??{$bal}))*\)/;
    if($text =~ m/Add(?:Bbh|Binary)SpatialCoordMaps${bal}[;,]/) {
      my $dum = $&;
      if($dum =~ m/TransMapWidth=([^;\)]+)[;\)]/) {
        $Width = $1;
      } elsif($dum =~ m/TransMapMaxRadius=([^;\)]+)[;\)]/) {
        # TransMapMaxRadius should be used as the width, provided
        # the falloff is 38.
        $Width   = $1;
        # This is dangerous.  Needs to be a better way.
        # If anyone changes the code in AddBbhSpatialCoordMaps, then
        # this will be wrong.
        $Falloff = 38;
      } else {
        # This is even more dangerous.  Needs to be a better way.
        # If anyone changes the code in AddBbhSpatialCoordMaps, then
        # this will be wrong.
        die "Trying to use Rmax0 (the outer boundary radius), but it's ".
            "not yet defined" unless defined $params->{'Rmax0'};
        $Width   = $params->{'Rmax0'};
        $Falloff = 38;
      }
    } 
    # else fall through; width is not set.
  }

  die "Cannot read Transwidth from $file" unless defined $Width;
  $params->{'Transwidth'}   = $Width;
  $params->{'Transfalloff'} = $Falloff;

  print "Trans width   = ",$params->{'Transwidth'},"\n"if($opt_v);
  print "Trans falloff = ",$params->{'Transfalloff'},"\n"if($opt_v);
  
  return $params;
}

#---------------
# Fills $params->{'Rmax'} with the inertial-frame outer boundary
# assuming a CubicScaleMap.
sub ComputeRmaxFromCubicParams {
  my($params)=@_;

  my $a0     = $params->{'a0AtMatch'};
  my $R      = $params->{'R'};
  my $a      = $params->{'a'};
  my $Rmax0  = $params->{'Rmax0'};
  $params->{'Rmax'}  = (defined $R ? 
                        $Rmax0*($a+($a0-$a)*($Rmax0/$R)**2) 
                        : $Rmax0);
  print "Determined Rmax at match = ",$params->{'Rmax'},"\n" if($opt_v);
  return $params;
}

#---------------
# Returns the deriv order of a FunctionVsTimeNthDeriv history file.
# If the history file is a FunctionVsTime3rdDeriv history file, returns UNDEF.
# This is used both to get the order, and to choose which type of history
# file it is.
sub DerivOrderOfHistoryFile {
  my($file)=@_;

  my $output = undef;
  open(FILE,"<$file") or croak "Cannot open $file";
  while(my $line=<FILE>) {
    if ($line =~ m|DerivOrder\s*=\s*(\d+)\s*;|) {
      $output = $1;
      last;
    }
  }
  close(FILE);
  return $output;
}

#---------------
sub GetRotationExpansionMapFnVsTimeType {
  my($histdir,$params)=@_;

  if($opt_nopremergermap) {
    $params->{'RotationMapFnVsTimeNthDeriv'}  = undef;
    $params->{'ExpansionMapFnVsTimeNthDeriv'} = undef;
    return 1;
  }

  my $userotation  = $params->{'UseRotationMap'};
  if($userotation eq 'PitchAndYaw') {
    $params->{'RotationMapFnVsTimeNthDeriv'}
    = DerivOrderOfHistoryFile("${histdir}/Hist-FuncPitchAndYaw.txt");
  } elsif($userotation eq 'QuaternionRotInv') {
    $params->{'RotationMapFnVsTimeNthDeriv'}
    = DerivOrderOfHistoryFile("${histdir}/Hist-FuncQuatRotMatrix.txt");
  } elsif($userotation eq 'QuaternionFvT') {
    # If using QuatFvT, $params->{'RotationMapFnVsTimeNthDeriv'} is used
    # as the deriv order of omega to construct the initial quaternion.
    $params->{'RotationMapFnVsTimeNthDeriv'}
    = DerivOrderOfHistoryFile("${histdir}/Hist-FuncOmega.txt");
  } elsif($userotation eq "NoHistory") {
    $params->{'RotationMapFnVsTimeNthDeriv'}
    = 2; # all SettleToXXX are 2nd order functions
  } elsif($userotation ne "None") {
    die "Don't understand userotation='",$userotation,"'";
  }

  my $useexpansion = $params->{'UseExpansionMap'};
  if($useexpansion eq "Expansion") {
    $params->{'ExpansionMapFnVsTimeNthDeriv'}
    = DerivOrderOfHistoryFile("${histdir}/Hist-FuncExpansionFactor.txt");
  }
}

#---------------
# Reads a "SpatialCoordMap.input" file containing a CubicScale map
# and returns the parameters of that map.
# Outputs 
# $params->{'R'}                = $R;
# $params->{'ExpansionFactorA0FnVsTime'} = $a0F;
sub GetCubicMapParams {
  my($file,$params)=@_;

  if($opt_nopremergermap) {
    $params->{'R'}                         = undef;
    $params->{'ExpansionFactorA0FnVsTime'} = undef;
    return 1;
  }

  my $text = Utils::ReadFile($file);
  $text =~ s/#.*$//mg; # Remove comments ('m' means $ matches end of each line)
  $text =~ s/\n//g;    # Remove newlines
  $text =~ s/\s+//g;   # Remove whitespace

  # Check for the badly-designed "Map=ReadFromFile" construct
  {
    our $bal;  $bal = qr/\((?:(?>[^()]+)|(??{$bal}))*\)/;
    while($text =~ m/SpatialCoordMapItems${bal}[;,]/g) {
      my $dum = $&;
      if($dum =~ m/Map=ReadFromFile\(FileName=([^;\)]+)[;\)]/) {
        print "GetCubicMapParams will read from file $opt_inputdir/$1\n" 
            if($opt_v);
        return GetCubicMapParams("$opt_inputdir/$1",$params); # Recursive call
      }
    }
  }

  my $R   = undef;
  my $a0B = undef;
  my $a0F = undef;
  if($text =~ m/CubicScaleToSpecified\([^()]*R\s*=([^;\)]+)[;\)]/) {
    $R  = $1;
  } elsif ($text =~ m/SmoothRotScale\([^()]*R\s*=([^;\)]+)[;\)]/) {
    $R  = $1;
  }
  if($text =~ m/CubicScaleToSpecified\([^()]*
                     ExpansionFactorB=([^;\)]+)[;\)]/x) {
    $a0B= $1;
  } elsif($text =~ m/SmoothRotScale\([^()]*
                     ExpansionFactorB=([^;\)]+)[;\)]/x) {
    $a0B= $1;
  } else {
    ### $bal matches balanced parens with possible nested parens inside.
    our $bal;  $bal = qr/\((?:(?>[^()]+)|(??{$bal}))*\)/;
    if($text =~ m/Add(?:Bbh|Binary)SpatialCoordMaps${bal}[;,]/) {
      my $dum = $&;
      if($dum =~ m/ExpansionFactorOuterBdry=([^;\)]+)[;\)]/) {
        $a0B = $1;
      }
      if($dum =~ m/OuterBdryRadius=([^;\)]+)[;\)]/) {
        $R = $1;
      }
    }
  }

  if(defined $a0B) {
    ### $bal matches balanced parens with possible nested parens inside.
    our $bal;  $bal = qr/\((?:(?>[^()]+)|(??{$bal}))*\)/;
    while($text =~ m/FunctionVsTime\s*${bal}[;,]/g) {
      my $dum = $&;
      if($dum =~ m/Output=$a0B/) {
        if($dum =~ m/FunctionVsTime=([^();]+$bal)/) {
          $a0F =  $1;
          $a0F =~ s/[;.]$//;
          last;
        }
      }
    }

    if(! defined $a0F) {
      # Uhoh, we need to look in different input files for a0B
      foreach my $f(glob "$opt_inputdir/*.input") {
        my $txt = Utils::ReadFile($f);
        $txt =~ s/#.*$//mg; # Rm comments ('m' means $ matches end of line)
        $txt =~ s/\n//g;    # Rm newlines
        $txt =~ s/\s+//g;   # Rm whitespace
        while($txt =~ m/FunctionVsTime${bal}[;,]/g) {
          my $dum = $&;
          if($dum =~ m/Output=$a0B/) {
            if($dum =~ m/FunctionVsTime=([^();]+$bal)/) {
              $a0F =  $1;
              $a0F =~ s/[;.]$//;
              last;
            }
          }
        }
        last if defined $a0F;
      }
    }
    die "Found a0B=$a0B but couldn't find definition" unless defined $a0F;
  }
  
  die "Cannot read CubicScale a0 from $file" unless (defined $a0F);
  die "Cannot read CubicScale R from $file" unless defined $R;

  $params->{'ExpansionFactorA0FnVsTime'} = $a0F;
  $params->{'R'}                         = eval($R);

  return $params;
}

#---------------
# Determines the scale factor at time tmatch.
# Outputs 
# $params->{'a'} = $a;
sub EvaluateCubicMapA {
  my($inputdir,$tmatch,$params)=@_;
  local $_;

  if($opt_nopremergermap) {
    $params->{'a'} = 1.0;
    print "Determined A at match = 1\n" if($opt_v);
    return 1;
  }

  if($params->{'UseExpansionMap'} eq "None") {
    $params->{'a'} = 1.0;
    print "NO Expansion map, setting A to 1\n" if($opt_v);
    return 1;
  }

  my $FnVsTime;
  if($params->{'UseExpansionMap'} eq "Expansion") {

    my $histfile   = "$inputdir/Hist-FuncExpansionFactor.txt";
    my $derivorder = DerivOrderOfHistoryFile($histfile);
    $FnVsTime = "
                  NthTimeDeriv(InitialData=Values(f=0.0;df=0.0;Tstart=0);
                               DerivOrder=$derivorder;
                               ComponentLabels=Specified(Labels=a);
                               ForceReplayMode=yes;
                               FileBaseName=FuncExpansionFactor;)";
  } else {
    $FnVsTime = $params->{'ExpansionMapFvT'};
  }

  my $ApplyObsInput = <<"EoF";
DataBoxItems = 
    Domain(Items=
           FunctionVsTime(Output=ExpansionFactor;
                          FunctionVsTime=$FnVsTime;
           );
    );
Observers = FunctionVsTime(Input         = ExpansionFactor;
                           FileBaseNames = Temp$$; 
    );
EoF

  my $tempdir = "EvaluateCubicMapA.$$";
  my $A = EvaluateCubicMapHelper($ApplyObsInput, $tmatch, $tempdir);
  $params->{'a'} = $A;

  print "Determined A at match = $A\n" if($opt_v);
}

#---------------
# Determines the scale factor at time tmatch.
# Outputs 
# $params->{'a0AtMatch'} = $a;
sub EvaluateCubicMapA0 {
  my($tmatch,$params)=@_;
  local $_;

  if($opt_nopremergermap) {
    $params->{'a0AtMatch'} = 1.0;
    print "Determined A0 at match = 1\n" if($opt_v);
    return 1;
  }

  my $FnVsTime = $params->{'ExpansionFactorA0FnVsTime'};
  return unless(defined $FnVsTime);

  my $ApplyObsInput = <<"EoF";
DataBoxItems = 
    Domain(Items=
           FunctionVsTime(Output        =ExpansionFactor;
                          FunctionVsTime=$FnVsTime;
           );
    );
Observers = FunctionVsTime(Input         = ExpansionFactor;
                           FileBaseNames = Temp$$; 
    );
EoF

  my $tempdir = "EvaluateCubicMapA0.$$";
  my $A = EvaluateCubicMapHelper($ApplyObsInput, $tmatch, $tempdir);
  $params->{'a0AtMatch'} = $A;

  print "Determined A0 at match = $A\n" if($opt_v);
}

#---------------
# Helper function for EvaluateCubicMap{A,A0}
sub EvaluateCubicMapHelper {
  my($ApplyObsInput, $tmatch, $tempdir)=@_;

  # Make temp dir and copy files there.
  CreateDirs(\$tempdir);
  chdir $tempdir || die "Cannot chdir $tempdir";
  my @filestocleanup = CopyFilesFromInputDir();

  # Run applyobservers
  my $tempfile      = "ApplyObservers.$$.input";
  Utils::OverwriteFile($tempfile, $ApplyObsInput);
  my $aoopts = "-UseTimes=$tmatch -domaininput=GrDomain.input";
  Utils::System("$APPLYOBS1 $aoopts $tempfile", $opt_v);

  # Parse output
  my $A=undef;
  my @text = Utils::ReadFile("Temp$$.dat");
  foreach(@text) {
    next if(/\s*#/); # Skip comments
    my @a = split;
    $A = $a[1];
  }

  unlink($tempfile) || die;
  unlink("Temp$$.dat") || die;
  unlink(glob "*.txt");
  unlink(@filestocleanup,glob("D*.input")) || die;
  chdir $THISDIR || die "Cannot chdir $THISDIR";
  rmdir $tempdir || die "Cannot rmdir $tempdir";

  return $A;
}

#---------------
# Returns the subset of timestocheck that actually occur in the given file.
sub TimesThatExistInAhFile {
  my($file,@timestocheck)=@_;

  # Get all the times in the file.
  my @timesinfile;
  my @text = Utils::ReadFile($file);
  foreach(@text) {
    next if(/\s*#/); # Skip comments
    my @a = split;
    push(@timesinfile,$a[0]);
  }

  my @times;
  foreach my $time (@timestocheck) {
    foreach my $tf (@timesinfile) {
      if($time == $tf) {
        push(@times,$time);
        last; # Do not need to check any more times in the file
      }
    }
  }

  return @times;
}

#---------------
sub GetMergerChunkSize {
  my($params)=@_;
  
  unless (defined $params->{'MatchCheckpointDir'}) {
    die "Checkpoint dir not yet defined";
  }
  my $file = $params->{'MatchCheckpointDir'}."/Cp-EvolutionLoopControl.txt";
  my $ChunkSize = undef;
  my $text = Utils::ReadFile($file);
  $text =~ s/\s*//g;
  if ($text =~ /SubChunksPerChunk=(\d+);.*DeltaTOfEachSubChunk=([^;]+);/) {
    $ChunkSize = $1 * $2;
  }
  
  die "Couldn't get ChunkSize from $file" unless (defined $ChunkSize);
  print STDOUT "Found ChunkSize = $ChunkSize\n" if ($opt_v);
  return $ChunkSize;
}

#---------------
# Gets the minimum L measured on the AhC during the inspiral.
# Note that the "Lmax" in the function name refers to the fact that
# the result is used to set the maximum L of ringdown shape control.
# We have to use the minimum L from the inspiral AhC to ensure that
# there exist derivatives for all L that we use in the ringdown.
sub GetLmaxOfAhC {
  my($params)=@_;
  local $_;
  my @times = @{$params->{'DerivTimes'}};

  my @files;
  foreach my $ahinputdir (@InputDirs) {
    my $file = "$ahinputdir/$opt_contdirname/AhC.dat";
    push(@files,$file) if (-f $file);
  }
  my $Lsurf = undef;
  foreach my $file(@files) {
    my $col   = undef;
    my @text = Utils::ReadFile($file);
    foreach(@text) {
      if(/^\s*#\s*\[(\d+)\]\s*=\s*L_surface/) {
        # Find column with L_surface
        $col = $1;
      } elsif(/^\s*#/) {
         # Skip other comments
      } elsif(defined $col) {
        s/^\s*//; # Remove leading whitespace
        my @a  = split;
        foreach my $time (@times) {
          if($a[0] == $time) {
            my $temp = $a[$col-1];
            if(!defined($Lsurf) || $Lsurf>$temp) {
              $Lsurf=$temp;
            }
          }
        }
      }
    }
  }
  die "Cannot find L_surface in @files" unless(defined $Lsurf);
  # Make Lsurf an integer
  $Lsurf = sprintf("%d",$Lsurf+0.5);
  return $Lsurf;
}

sub GetIndividualHorizonCenters {
  my($params)=@_;

  my $text = 
      Utils::ReadFile("$opt_inputdir/GrDomain.input");
  $text =~ s/#.*$//mg; # Remove comments
  $text =~ s/\n//g;    # Remove newlines
  $text =~ s/\s+//g;   # Remove whitespace
  
  my %Center;
  foreach my $ab ("A","B") { # Do for both A and B.
    if ($text =~ m/Center$ab=([^;]+);/) {
      $Center{$ab} = $1;
      print "Found center$ab = $Center{$ab}\n" if ($opt_v);
    } else {
      die "Could not get Center$ab from " .
          "$opt_inputdir/GrDomain.input";
    }
  }
  $params->{'CenterA'} = $Center{'A'};
  $params->{'CenterB'} = $Center{'B'};
}

#---------------
# Sets the following parameters:
# $params->{'MatchTime'}  -- Time at which we do the match.
# $params->{'DerivTimes'} -- Times for the derivatives.
# $params->{'NearestDerivTimeToMatchTime'}
# Possibly sets $opt_matchtime as well.
sub GetTimesAndStepsForAhStencil {
  my($params)=@_;

  # Get all the times
  my @times;
  my @files;
  foreach my $ahinputdir (@InputDirs) {
    foreach my $file (glob "$ahinputdir/$opt_contdirname/AhC_*Coefs.dat") {
      push(@files,$file) if (-f $file);
    }
  }
  if(scalar(@files)<=0) {
    foreach my $ahinputdir (@InputDirs) {
      foreach my $file (glob "$ahinputdir/$opt_contdirname/AhC*Coefs.dat") {
        push(@files,$file) if (-f $file);
      }
    }
  }
  foreach my $file(@files) {
    my @text = Utils::ReadFile($file);
    foreach(@text) {
      next if(/\s*#/); # Skip comments
      my @a = split;
      push(@times,$a[0]);
    }
  }
  # Sort the times
  @times=sort { $a <=> $b }(@times);

  # Get matchstep and reset matchtime if desired.
  my $matchstep=0;
  if(!defined $opt_matchtime) {
    $matchstep     = $#times;
    $opt_matchtime = $times[$#times];
  } else {
    my $mindiff = 100000;
    foreach my $i (0..$#times) {
      my $diff = abs($times[$i]-$opt_matchtime);
      if($diff<$mindiff) {
        $matchstep = $i;
        $mindiff   = $diff;
      }
    }
  }

  # Get first and last
  my $last  = $matchstep+$opt_stencil;
  my $first = $matchstep-$opt_stencil;
  {
    my $ntimes = scalar(@times);
    if($opt_stencil>2) {
      if($first<0) {
        $first  = 0;
        $last   = 2*$opt_stencil;
      }
      if($last>=$ntimes) {
        $last  = $ntimes-1;
        $first = $last-2*$opt_stencil;
      }
    }
    # Not enough data points to fill the stencil
    if($last>=$ntimes or $first<0) {
      my $NumExpectedPoints = $last - $first + 1;   # 2*opt_stencil+1
      die "Not enough data points to fill the stencil. Expecting ".
          "$NumExpectedPoints points for stencil size $opt_stencil. ".
          "Times found are @times, first=$first, last=$last, and ".
          "match=$matchstep, looking in $opt_inputdirs.\n";
    }
  }
  $params->{'MatchTime'}                    = $opt_matchtime;
  $params->{'NearestDerivTimeToMatchTime'}  = $times[$matchstep];
  $params->{'DerivTimes'}                   = [ @times[$first..$last] ];
}

#-------------------------------------------------------------------
#-------------------------------------------------------------------
# Routines that copy and link files
#-------------------------------------------------------------------
#-------------------------------------------------------------------

sub CopyFilesFromSrcDir 
{
  my($srcdir)=@_;
  local $_;
  
  my @links;
  opendir(DIR,"$srcdir") || die "Cannot opendir $srcdir";
  my(@entry)=readdir(DIR);
  closedir(DIR);
  
  foreach my $link(@entry) {
    next if ($link eq '.' || $link eq '..'); 
    if ($link  =~ m/\.input$/ || $link =~ m/^Hist-/) {
      Utils::MyCopy("$srcdir/$link","$link");
      push(@links,$link);
    }
  }
  return(@links);
}

#---------------
# Copy files from opt_inputdir to CWD (which does not need to be $THISDIR).
# Returns the files copied.
sub CopyFilesFromInputDir 
{
  return if($opt_inputdir eq $THISDIR);
  return CopyFilesFromSrcDir($opt_inputdir);
}

#-------------------------------------------------------------------
#-------------------------------------------------------------------
# Utility routines for directories and so forth
#-------------------------------------------------------------------
#-------------------------------------------------------------------

#---------------
# Given a set of directory references, replaces them with absolute pathnames.
sub MakeDirectoriesAbsolute {
  my(@dirrefs)=@_;

  my $cwd = cwd();
  foreach my $dirref (@dirrefs) {
    next unless defined($$dirref);
    chdir($$dirref) || die "Cannot chdir $$dirref";
    $$dirref = `/bin/pwd`; chomp $$dirref;
    chdir($cwd) || die "Cannot chdir $cwd";
  }
}

#---------------
sub CreateDirs {
  my(@dirrefs)=@_;

  foreach my $dirref (@dirrefs) {
    my $dir = $$dirref;
    mkdir($dir) || die "Cannot mkdir $dir";
  }
}

#---------------
sub CreateDirsIfNotThere {
  my(@dirrefs)=@_;

  foreach my $dirref (@dirrefs) {
    my $dir = $$dirref;
    -d $dir || mkdir($dir) || die "Cannot mkdir $dir";
  }
}

#---------------
sub OnlyFewDigits 
{
  my($a)=@_;
  if($a>=10) {
    $a = sprintf("%i",$a);
  } elsif($a>=2) {
    $a = sprintf("%2.1f",$a);
  } else {
    $a = sprintf("%2.2f",$a);
  }
  return $a;
}
