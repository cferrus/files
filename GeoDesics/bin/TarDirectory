#!/usr/bin/env perl
require 5;
use warnings;
use strict;
use vars qw($ME $THISDIR $HOST $EXT $z
            $opt_h $opt_v $opt_n $opt_T $opt_S $opt_z $opt_s $opt_a);
use File::stat;
use Getopt::Std;
use File::Path qw(mkpath);
use Cwd;
use Sys::Hostname;
use File::Basename;
# Load SpEC perl modules
use lib dirname(Cwd::abs_path(__FILE__));
use Utils;

#-----------------------------------------
# Constants
#-----------------------------------------
$ME      = basename(__FILE__);         # Name of this executable
$THISDIR = getcwd();
$SIG{'PIPE'} = 'IGNORE';    # Ignore broken pipes so that errors can be caught

#-----------------------------------------
# Options
#-----------------------------------------
$opt_v    = 1;
$opt_n    = undef;
$opt_S    = "1000GB";
$opt_h    = undef;
$opt_z    = undef;
$opt_a    = "";
sub Help {
    print STDERR <<"EoF";
Usage: $ME [options] src dest
  Tars src (must be a directory) and sends it to dest (which must not exist):

    * Duplicates the entire directory tree of src. All files src/* that are not
      directories will be tarred into a single tar file inside dest, and
      similarly for each subdirectory of src, and so on down the tree.
      NOTE: there is no recursion if the simple (-s) option is specified.
    * The name of the single tar file will be BLA_0.tar, where BLA is the name
      of the parent directory.
    * If the tar file would exceed some set size limit (see -S option),
      then the tar file is split into several files BLA_0.tar, BLA_1.tar, etc.
    * If dest contains a colon, i.e. hostname:mydir, then dest will be created
      on the remote machine hostname using ssh.

   Symbolic links are ignored when traversing the directory tree.
   WARNING: resulting tars are tarbombs!

OPTIONS:
  -s               Simple. Do not recurse, but include all subdirs in first tar.
  -z               Gzip the tar files. Default false.
  -n               No!  Just print what it would do, but do not do it.
  -S SIZE          Max size of each tar file, in bytes. Default $opt_S.
                   It recognizes the string 'GB' or 'MB' in the specification.
  -v int           Verbosity level from 0-2. Default $opt_v.
  -a EMAIL         Send failure notifications to these e-mail addresses.
                   Use a comma-delimited list to specify. Default '$opt_a'.
  -h               Help. Print this table.
EoF
    exit(1);
}

#-----------------------------------------
# MAIN ROUTINE
#-----------------------------------------

# Read arguments
getopts('a:shnTv:zS:') || Help(); Help() if $opt_h;

if(scalar(@ARGV) != 2) {
  print STDERR "$ME: Need exactly two arguments: src and dest directories.\n";
  Help();
}

$opt_v=2 if($opt_n);
if($opt_S =~ m/(.*)\s*GB$/) {
  $opt_S = $1 * 1000000000;
} elsif($opt_S =~ m/(.*)\s*MB$/) {
  $opt_S = $1 * 1000000;
}

# If we're gzipping, use the 'z' flag in tar and add .gz to the extension
$z   = ($opt_z ? "z" : "");
$EXT = ($opt_z ? ".tar.gz" : ".tar");


main();
print "$ME: Finished successfully\n" if ($opt_v > 0);
exit 0;

sub main {
  my $src  = $ARGV[0];
  my $dest = $ARGV[1];

  # Remove trailing slashes on $src, $dest if present, to not screw things up.
  $src  =~ s|/+$||;
  $dest =~ s|/+$||;

  # Is dest a remote directory?
  $HOST = undef;
  if($dest =~ s/^([^:]+)://) {
    $HOST = $1;
  }

  # Run in an eval statement to catch errors
  eval {
    # Make dest and replace it with its absolute path.
    $dest = Mkdir($dest) unless ($opt_n);

    # Do all the dirty work
    TarDirectory($src,$dest);
  };
  if ($@) {
    # Catch errors
    EmailErrors($@,$ARGV[0],$ARGV[1]);
    print STDERR "If this is an ssh error (eg. Permission denied),\n"
      . "then you might not have passwordless access to the remote\n"
      . "machine. Check the appropriate SXS Wiki machine page for info.\n";
    die "$ME: caught error: $@";
  }
}


#-----------------------------------------
# Subroutines
#-----------------------------------------

# mkdir and return the absolute path (when applicable) to the new directory
sub Mkdir {
  my($dir)=@_;

  if (defined $HOST) {
    Utils::System("ssh $HOST mkdir -p $dir", $opt_v-1);
  } else {
    mkpath($dir) || die "$ME: Cannot mkdir $dir\n";
    $dir = Cwd::realpath($dir) || die "$ME: Cannot realpath $dir\n";
  }
  return $dir;
}

#---------------
# Copies src into dest.
# Assumes that $src exists and is a directory.
# Assumes that $dest exists, is a directory, and is an ABSOLUTE path.
sub TarDirectory {
  my($src,$dest)=@_;
  local $_;

  print "$ME: $src to $dest\n" if ($opt_v > 0);

  # Read the src directory
  opendir(DIR,"$src") || die "$ME: Cannot open $src\n";
  my(@entry) = readdir(DIR);
  closedir(DIR);

  my(@files)=();
  foreach(@entry) {
    my $x = "$src/$_";
    next if ($_ eq '.' || $_ eq '..');  # Skip "." and ".." entries!
    next if (-l "$x");                  # Skip symlinks

    if ($opt_s || (not -d "$x")) {
      # Just push the basename, because we will cd into $src before tarring.
      # If '-s', do this for all, including dirs. If not '-s', only files.
      push(@files,$_);
    } else {
      # Make destination directory
      Mkdir("$dest/$_") unless ($opt_n);
      TarDirectory($x,"$dest/$_");      # Recursive call
    }
  }

  # Base path for the destination tar file.
  my $destfile = $src; $destfile =~ s|.*/||; $destfile = "$dest/$destfile";

  # We want to chdir to the src directory because otherwise the tar archive
  # will have lots of pathname stuff in front of each file.
  chdir $src     || die "$ME: Cannot chdir $src\n";
  TarFilesUpToSize($destfile,$opt_S,@files);
  chdir $THISDIR || die "$ME: Cannot chdir $THISDIR\n";
}

#---------------
# Tars a set of files into "$destfile_0.tar", "$destfile_1.tar", etc...
# The number of tar files created is chosen so that each file is smaller
# than $maxsize.
sub TarFilesUpToSize {
    my($destfile,$maxsize,@files) = @_;
    my @temps     = ();
    my $temp      = [];
    my $totalsize = 0;
    foreach my $file (@files) {
        my $stat    = stat($file);
        $totalsize += $stat->size;
        push(@$temp,$file);
        if($totalsize > $maxsize) {
            die "$ME: Too big of file" if(scalar(@$temp)==1);
            push(@temps,$temp);
            $temp      = [];
            $totalsize = 0;
        }
    }
    push(@temps,$temp) unless (scalar(@$temp) == 0);

    my $num = 0;
    foreach my $chunk (@temps) {
      TarFiles($destfile . "_" . $num . $EXT, @$chunk);
      ++$num;
    }
}

#---------------
# Tars a (possibly large) set of files to a destination filename.
sub TarFiles {
  my($dest,@files)=@_;

  # Make a file containing the files to tar.
  print "$ME: Files to tar:\n@files\n" if ($opt_v > 1);
  my $tempfile = "TempFilesToTar.".$$;
  open(FILE,">$tempfile") || die "$ME: Cannot open temp file $tempfile\n";
  foreach my $file (@files) {
    print FILE $file,"\n";
  }
  close(FILE);

  if (defined $HOST) {
    # Remote dest file (use pipes from tar->ssh->cat)
    # Set the pipes to binmode to prevent character translation
    # Pass 8MB of the tar pipe to the ssh pipe at a time
    my $pipe1 = "tar -c${z}f - --files-from $tempfile |";
    my $pipe2 = "| ssh $HOST 'cat > ${dest}'";
    print "PIPE1=$pipe1\nPIPE2=$pipe2\n" if ($opt_v > 1);
    open(TAR,$pipe1) || die "Cannot open pipe from tar\n";
    open(SSH,$pipe2) || die "Cannot open pipe to ssh\n";
    binmode(TAR) || die "Cannot put tar in binary mode\n";
    binmode(SSH) || die "Cannot put ssh in binary mode\n";
    my ($data,$n);
    while (($n = read(TAR,$data,8*1024*1024)) != 0) {
      print "$ME: $n bytes read from tar\n" if ($opt_v > 1);
      print(SSH $data) unless ($opt_n);
    }
    close(TAR) || die "$ME: Cannot close tar\n";
    close(SSH) || die "$ME: Cannot close ssh\n";
  } else {
    # Local dest file (just execute tar)
    my $cmd = "tar -c${z}f $dest --files-from $tempfile";
    Utils::System($cmd, $opt_v-1) unless $opt_n;
  }
  unlink($tempfile) || die "$ME: Cannot unlink $tempfile\n";
}

#---------------
sub EmailErrors {
  my($err,$src,$dest) = @_;
  if ($opt_a eq "" || $opt_a eq "__EmailAddresses__") {
    return; # Only continue if email addresses are specified
  }
  print "$ME: Sending failure notice e-mail\n" if ($opt_v > 0);
  my $Subject = "SpEC segment backup failed";
  my $Host = hostname();
  my $Body = "$ME: on $Host from $src to $dest\n\n" .
             "See log file on $Host if error below is ambiguous.\n" .
             "############ ERROR MESSAGE ############\n$err";

  Utils::SendMail(subject=>$Subject, body=>$Body, sleep=>90,
                  to=>$opt_a, v=>$opt_v) unless ($opt_n);

  print "$ME: mail command executed.\n" if ($opt_v > 1);
}
